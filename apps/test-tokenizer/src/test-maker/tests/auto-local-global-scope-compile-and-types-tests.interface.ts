import { IAutoLocalGlobalScopeCompileTest } from '../tests.interface';

/**
 * Tests verifying our local, global, and compile options are set.
 *
 * As part of this, we export our local items (i.e. variables) which contains
 * type information.
 */
export const AUTO_LOCAL_GLOBAL_SCOPE_COMPILE_AND_TYPES_TESTS: IAutoLocalGlobalScopeCompileTest[] =
  [
    {
      suiteName: `Correctly gets docs and variables`,
      fileName: `all-docs-work-right.spec.ts`,
      tests: [
        {
          name: 'for a routine',
          code: [
            ``,
            `;+`,
            `; My procedure`,
            `;`,
            `; :Args:`,
            `;  var1: in, required, any`,
            `;    My favorite thing`,
            `;`,
            `; :Keywords:`,
            `;  kw1: in, optional, type=boolean`,
            `;    Super Cool flag`,
            `;`,
            `;-`,
            `pro mypro, var1, KW1=kw1`,
            `  compile_opt idl2`,
            `  ;+ awesome variable with docs`,
            `  a = 42`,
            `  ;+`,
            `  ; Big comment block here`,
            `  ; like a great code writer`,
            `  ;-`,
            `  b = 42`,
            `end`,
            ``,
          ],
        },
      ],
    },
    {
      suiteName: `Correctly extract variables from`,
      fileName: `common.spec.ts`,
      tests: [
        {
          name: 'common, excluding the first of the common block',
          code: [
            `pro color_edit_back`,
            `compile_opt idl2`,
            ``,
            `common color_edit, wxsize, wysize, r0`,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Complex real world test`,
      fileName: `complex-docs-example1.spec.ts`,
      tests: [
        {
          name: `with past failure in complex docs`,
          code: [
            `;h+`,
            `; Copyright (c) 2018 Harris Geospatial Solutions, Inc.`,
            `; `,
            `; Licensed under MIT. See LICENSE.txt for additional details and information.`,
            `;h-`,
            ``,
            ``,
            ``,
            `;+`,
            `; :Description:`,
            `;    Tool for determining the intersection between two rasters based on their`,
            `;    spatial reference and spatial extent. Both rasters will also contain only`,
            `;    the valid pixels from each scene for  analysis. In other words, if a pixel`,
            `;    is \`off\` in the first image and not the second, it will be turned \`off\` in`,
            `;    each of the output rasters for consistency. If one of the rasters does not`,
            `;    have a data ignore value, then a pixel state mask is automatically generated`,
            `;    so that you can mask the output rasters if needed.`,
            `;    `,
            `;    The pixel size of the output rasters will be the smallest x and y`,
            `;    pixel size from each raster.`,
            `;`,
            `;`,
            `;`,
            `; :Examples:`,
            `;    \`\`\`idl`,
            `;    ;start ENVI`,
            `;    e = envi(/HEADLESS)`,
            `;    `,
            `;    ;make sure we have access to our ENVI tasks`,
            `;    awesomeENVIAlgorithms, /INIT`,
            `;    `,
            `;    ;specify two rasters to process`,
            `;    raster1 = e.openRaster(file1)`,
            `;    raster2 = e.openRaster(file2)`,
            `;    `,
            `;    ;get our task`,
            `;    task = ENVITask('AwesomeRasterIntersection')`,
            `;    task.INPUT_RASTER1 = raster1`,
            `;    task.INPUT_RASTER2 = raster2`,
            `;    task.execute`,
            `;    `,
            `;    ;print our output locations`,
            `;    print, task.OUTPUT_RASTER1_URI`,
            `;    print, task.OUTPUT_RASTER2_URI`,
            `;    \`\`\``,
            `;`,
            `; :Keywords:`,
            `;    DEBUG: in, optional, type=boolean, private`,
            `;      If set, errors are stopped on.`,
            `;      Add a link to make sure it doesn't get picked up`,
            `;        https://en.wikipedia.org/wiki/Haversine_formula`,
            `;        http://en.wikipedia.org/wiki/Haversine_formula`,
            `;        ftp://en.wikipedia.org/wiki/Haversine_formula`,
            `;        s3://en.wikipedia.org/wiki/Haversine_formula`,
            `;        file://en.wikipedia.org/wiki/Haversine_formula`,
            `;    DATA_IGNORE_VALUE: in, optional, type=number`,
            `;      If one or both of your input rasters do not have`,
            `;      a data ignore value metadata item, you can specify`,
            `;    GENERATE_PIXEL_STATE_MASK: in, optional, type=boolean`,
            `;      If set, then an addititonal output raster is created`,
            `;      that represents which pixels can be processed or not.`,
            `;      `,
            `;      This will automatically be generated if one of the input`,
            `;      images does not have a data ignore value.`,
            `;    INPUT_RASTER1: in, required, type=ENVIRaster`,
            `;      Specify the first raster to use for intersection.`,
            `;    INPUT_RASTER2: in, required, type=ENVIRaster`,
            `;      Specify the second raster to use for intersection`,
            `;    OUTPUT_GRID_DEFINITION: out, optional, type=ENVIGridDefinition`,
            `;      Optionally return the ENVIGridDefinition object used to get the intersection`,
            `;      of the two scenes.`,
            `;    OUTPUT_RASTER1_URI: in, optional, type=string`,
            `;      Optionally specify the fully-qualified filepath`,
            `;      for the location of the first intersect raster.`,
            `;    OUTPUT_RASTER2_URI: in, optional, type=string`,
            `;      Optionally specify the fully-qualified filepath`,
            `;      for the location of the second intersect raster.`,
            `;    OUTPUT_MASK_RASTER_URI: in, optional, type=string`,
            `;      Optionally specify the fully-qualified filepath`,
            `;      for the location of the pixel state mask. Only applies`,
            `;      when \`GENERATE_PIXEL_STATE_MASK\` is set or one of the `,
            `;      input rasters does not have a data ignore value.`,
            `;    RESAMPLING: in, optional, type=string`,
            `;      Optionally return the ENVIGridDefinition object used to get the intersection`,
            `;      of the two scenes. Specify one of the following options:`,
            `;      - Nearest Neighbor`,
            `;      - Bilinear`,
            `;      - Cubic Convolution`,
            `;`,
            `; :Tooltip:`,
            `;    Calculates the intersection of two rasters such that both`,
            `;    have the same spatial extent and spatial dimensions`,
            `;`,
            `; :Author: Zachary Norman - GitHub: [znorman-harris](https://github.com/znorman-harris)`,
            `;-`,
            `pro awesomeRasterIntersection, $`,
            `  DEBUG = debug,$`,
            `  DATA_IGNORE_VALUE = data_ignore_value,$`,
            `  GENERATE_PIXEL_STATE_MASK = generate_pixel_state_mask,$`,
            `  INPUT_RASTER1 = input_raster1,$`,
            `  INPUT_RASTER2 = input_raster2,$`,
            `  OUTPUT_MASK_RASTER_URI = output_mask_raster_uri,$`,
            `  OUTPUT_GRID_DEFINITION = output_grid_definition,$`,
            `  OUTPUT_RASTER1_URI = output_raster1_uri,$`,
            `  OUTPUT_RASTER2_URI = output_raster2_uri,$`,
            `  RESAMPLING = resampling`,
            `  compile_opt idl2, hidden`,
            `end`,
            ``,
          ],
        },
      ],
    },
    {
      suiteName: `Complex real world test`,
      fileName: `complex-docs-example2.spec.ts`,
      tests: [
        {
          name: `with past failure in complex docs`,
          code: [
            `;+`,
            `; :Description:`,
            `;    Function which will initialize the bdige_it object and start all bridges. When bridges are initialized`,
            `;    they are done so in parallel, but whe function will not return until every bridge is idle again.`,
            `;`,
            `; :Params:`,
            `;    nbridges: in, required, type=int`,
            `;       The number of bridges that you want to create`,
            `;`,
            `; :Keywords:`,
            `;    INIT : in, optional, type=strarr`,
            `;       Optional argument which allows you to pass in a string array of extra commands`,
            `;       to have each IDL_IDLBridge object execute upon creation.`,
            `;    MSG : in, optional, type=string`,
            `;       Optional argument to show the message prefix when a bridge process has completed for the TIME`,
            `;       keyword in bridge_it::run and bridge_it::run().`,
            `;    LOGDIR : in, optional, type=string`,
            `;       Specify the directory that the log file will be written to. The log file is just a text file with`,
            `;       all of the IDL Console output from each child process.`,
            `;    NREFRESH : in, optional, type=long`,
            `;       Specify the number of bridge processes to execute before closing and re-starting the`,
            `;       child process. Necessary for some ENVI routines so that we don't have memory fragmentation`,
            `;       regarding opening lots of small rasters.`,
            `;    PREFIX : in, optional, type=string, default='_KW_'`,
            `;       This optional keyword specifies the prefix which is used to differentiate between arguments and`,
            `;       keywords when it comes time to parse the arguments and keyword that will be passed into a routine.`,
            `;`,
            `; :Author: Zachary Norman - GitHub: [znorman-harris](https://github.com/znorman-harris)`,
            `;`,
            `;-`,
            `function bridge_it::Init, nbridges, INIT = init, MSG = msg, LOGDIR = logdir, NREFRESH = nrefresh, PREFIX = prefix`,
            `  compile_opt idl2, hidden`,
            `  on_error, 2`,
            ``,
            `  return, 1`,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Extract docs below routines`,
      fileName: `docs-below-1.spec.ts`,
      tests: [
        {
          name: 'for procedure',
          code: [
            `pro parse_docs_below, input_raster = input_raster, output_raster_uri = output_raster_uri, third2 = third`,
            `;+`,
            `; :Keywords:`,
            `;   input_raster: in, optional, ENVIRaster`,
            `;     Thing 1`,
            `;   output_raster_uri: in, optional, String`,
            `;     Thing 2`,
            `;   third: bidirectional, optional, any`,
            `;     Thing 3`,
            `;`,
            `;-  `,
            `compile_opt idl2`,
            ``,
            `; get the current session of ENVI`,
            `e = envi(/current)`,
            `if (e eq !null) then begin`,
            `  message, 'ENVI has not started yet, required!'`,
            `endif`,
            `idltasktest, input_raster = 5`,
            `end`,
          ],
        },
        {
          name: 'for function',
          code: [
            `function parse_docs_below, input_raster = input_raster, output_raster_uri = output_raster_uri, third2 = third`,
            `;+`,
            `; :Keywords:`,
            `;   input_raster: in, optional, ENVIRaster`,
            `;     Thing 1`,
            `;   output_raster_uri: in, optional, String`,
            `;     Thing 2`,
            `;   third: bidirectional, optional, any`,
            `;     Thing 3`,
            `;`,
            `;-  `,
            `compile_opt idl2`,
            ``,
            `; get the current session of ENVI`,
            `e = envi(/current)`,
            `if (e eq !null) then begin`,
            `  message, 'ENVI has not started yet, required!'`,
            `endif`,
            `idltasktest, input_raster = 5`,
            `return, 1`,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Parse legacy IDL Doc styles`,
      fileName: `docs-idldoc-legacy.1.spec.ts`,
      tests: [
        {
          name: 'for procedure',
          code: [
            `;+`,
            `; LatLon_Distance`,
            `;   Computes the distance of a rhumb line connecting two points on a sphere or spheroid`,
            `;`,
            `; @param lon1, lat1 {input} Longitude and latitude of the 1st point, p0`,
            `; @param lon2, lat2 {input} Longitude and latitude of the 2nd point, p1`,
            `; @param method {input} The method to be used, options are:`,
            `;   1 - Haversine (sphere) - selected by default`,
            `;   2 - Vincenty  (spheroid)`,
            `;`,
            `; @keyword meters  Set this keyword to return the distance in meters`,
            `; @keyword radians Set this keyword if inputs are specified in radians (the default is degrees)`,
            `; @keyword radius  Set this keyword to a value specifying the radius of the sphere to be used, in [km]`,
            `;   the default value is the Authalic radius (equal area hyothetical perfect sphere) = 6371.0072`,
            `; @keyword semimajor_axis Set this keyword to the length of the semimajor axis of the reference ellipsoid, in [m]`,
            `;   the default value is the WGS-84 6378137`,
            `; @keyword semiminor_axis Set this keyword to the length of the semiminor axis of the reference ellipsoid, in [m]`,
            `;   the default value is the WGS-84 6356752.314245`,
            `;`,
            `; @references`,
            `;   Haversine formula ( great-circle distance between two points on a sphere )`,
            `;     https://en.wikipedia.org/wiki/Haversine_formula`,
            `;   Vincenty formula ( distance between two points on the surface of a spheroid )`,
            `;     https://en.wikipedia.org/wiki/Vincenty%27s_formulae`,
            `;     https://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf`,
            `;`,
            `; @history`,
            `;   Thu Jul 29, 2021 - Introduce the Vincenty equation (computation of distances over an spheroid)`,
            `;   Sun Apr 23, 2023 - Fix the Vincenty calculation at latitudes close to zero`,
            `;   Wed May 10, 2023 - Allow arrays in the Vincenty method`,
            `;-`,
            `pro idltasktest, lon1, lat1, lon2, lat2, method, meters = meters, radians = radians, radius  = radius, semimajor_axis = semimajor_axis, semiminor_axis = semiminor_axis`,
            `  compile_opt idl2 `,
            ``,
            `end`,
          ],
        },
        {
          name: 'for function',
          code: [
            `;+`,
            `; LatLon_Distance`,
            `;   Computes the distance of a rhumb line connecting two points on a sphere or spheroid`,
            `;`,
            `; @param lon1, lat1 {input} Longitude and latitude of the 1st point, p0`,
            `; @param lon2, lat2 {input} Longitude and latitude of the 2nd point, p1`,
            `; @param method {input} The method to be used, options are:`,
            `;   1 - Haversine (sphere) - selected by default`,
            `;   2 - Vincenty  (spheroid)`,
            `;`,
            `; @keyword meters  Set this keyword to return the distance in meters`,
            `; @keyword radians Set this keyword if inputs are specified in radians (the default is degrees)`,
            `; @keyword radius  Set this keyword to a value specifying the radius of the sphere to be used, in [km]`,
            `;   the default value is the Authalic radius (equal area hyothetical perfect sphere) = 6371.0072`,
            `; @keyword semimajor_axis Set this keyword to the length of the semimajor axis of the reference ellipsoid, in [m]`,
            `;   the default value is the WGS-84 6378137`,
            `; @keyword semiminor_axis Set this keyword to the length of the semiminor axis of the reference ellipsoid, in [m]`,
            `;   the default value is the WGS-84 6356752.314245`,
            `;`,
            `; @returns The distance between the 2 points, [km] by default`,
            `;`,
            `; @references`,
            `;   Haversine formula ( great-circle distance between two points on a sphere )`,
            `;     https://en.wikipedia.org/wiki/Haversine_formula`,
            `;   Vincenty formula ( distance between two points on the surface of a spheroid )`,
            `;     https://en.wikipedia.org/wiki/Vincenty%27s_formulae`,
            `;     https://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf`,
            `;`,
            `; @history`,
            `;   Thu Jul 29, 2021 - Introduce the Vincenty equation (computation of distances over an spheroid)`,
            `;   Sun Apr 23, 2023 - Fix the Vincenty calculation at latitudes close to zero`,
            `;   Wed May 10, 2023 - Allow arrays in the Vincenty method`,
            `;-`,
            `function idltasktest, lon1, lat1, lon2, lat2, method, meters = meters, radians = radians, radius  = radius, semimajor_axis = semimajor_axis, semiminor_axis = semiminor_axis`,
            `  compile_opt idl2 `,
            ``,
            `  return, 1`,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Correctly extract docs for`,
      fileName: `document-vars.spec.ts`,
      tests: [
        {
          name: 'variables with single-line block',
          code: [
            `pro myclass::mymethod, var1`,
            `  compile_opt idl2`,
            `  ;+ meaning of life`,
            `  a = 42`,
            `end`,
          ],
        },
        {
          name: 'variables with multi-line block',
          code: [
            `pro myclass::mymethod, var1`,
            `  compile_opt idl2`,
            `  ;+`,
            `  ; Some things are really awesome`,
            `  ; and need a big description`,
            `  ;-`,
            `  a = 42`,
            `end`,
          ],
        },
        {
          name: 'only use docs from first encounter',
          code: [
            `pro myclass::mymethod, var1`,
            `  compile_opt idl2`,
            `  ;+`,
            `  ; Some things are really awesome`,
            `  ; and need a big description`,
            `  ;-`,
            `  a = 42`,
            ``,
            `  ;+ second docs are ignored`,
            `  a = 42`,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Correctly extract variables from`,
      fileName: `functions.spec.ts`,
      tests: [
        {
          name: 'functions',
          code: [
            `function myfunc, arg1, arg2, arg3, KW1=kw1,$ ; commment`,
            `  KW2 = kw2, KW3 = kw3`,
            `  compile_opt idl2`,
            ``,
            `  return, 1`,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Correctly extract variables from`,
      fileName: `function-methods.spec.ts`,
      tests: [
        {
          name: 'function methods',
          code: [
            `function myclass::mymethod, arg1, arg2, arg3, KW1=kw1,$ ; commment`,
            `  KW2 = kw2, KW3 = kw3`,
            `  compile_opt idl2`,
            ``,
            `  return, 1`,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Add function for`,
      fileName: `function-methods.init.spec.ts`,
      tests: [
        {
          name: 'class init methods',
          code: [
            `function MyClass::init, a, b, c, kw2 = kw2`,
            `  compile_opt idl2`,
            ``,
            `  ; set data type correctly for local variable`,
            `  z = MyClass()`,
            ``,
            `  return, 1`,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Correctly inherits docs for`,
      fileName: `inherit-args-docs.spec.ts`,
      tests: [
        {
          name: 'arguments',
          code: [
            ``,
            `;+`,
            `; My procedure`,
            `;`,
            `; :Args:`,
            `;  var1: in, required, any`,
            `;    My favorite thing`,
            `;`,
            `;-`,
            `pro mypro, var1`,
            `  compile_opt idl2`,
            `end`,
            ``,
          ],
        },
      ],
    },
    {
      suiteName: `Correctly inherits docs for`,
      fileName: `inherit-kw-docs.spec.ts`,
      tests: [
        {
          name: 'keywords',
          code: [
            ``,
            `;+`,
            `; My procedure`,
            `;`,
            `; :Keywords:`,
            `;  kw1: in, optional, type=boolean`,
            `;    Super Cool flag`,
            `;`,
            `;-`,
            `pro mypro, KW1=kw1`,
            `  compile_opt idl2`,
            `end`,
            ``,
          ],
        },
      ],
    },
    {
      suiteName: `Correctly inherits docs for`,
      fileName: `inherit-private-docs.spec.ts`,
      tests: [
        {
          name: 'private',
          code: [
            ``,
            `;+`,
            `; My procedure`,
            `;`,
            `; :Keywords:`,
            `;  kw1: in, optional, type=boolean, private`,
            `;    Super Cool flag`,
            `;`,
            `;-`,
            `pro mypro, KW1=kw1`,
            `  compile_opt idl2`,
            `end`,
            ``,
          ],
        },
      ],
    },
    {
      suiteName: `With lambda functions`,
      fileName: `lambda.no-vars.spec.ts`,
      tests: [
        {
          name: 'do not extract variables',
          code: [
            `; main level`,
            `compile_opt idl2`,
            `!null = lambda(n:n le 3 || min(n mod [2:fix(sqrt(n))]))`,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Correctly extract variables from`,
      fileName: `main.spec.ts`,
      tests: [
        {
          name: 'main level',
          code: [`compile_opt idl2`, `a = 5`, `mypro, a, b, c, d`, `end`],
        },
      ],
    },
    {
      suiteName: `Verify notebook parsing`,
      fileName: `notebook-parse.compile-opt.1.spec.ts`,
      tests: [
        {
          name: 'adds compile-opt idl2 for main and gets right default type',
          code: [`a = 42`, ``, `end`],
          config: {
            isNotebook: true,
          },
        },
      ],
    },
    {
      suiteName: `Verify notebook parsing`,
      fileName: `notebook-parse.compile-opt.exceptions.spec.ts`,
      tests: [
        {
          name: 'ignores compile opt idl2 for procedures',
          code: [`pro myPro`, `  print, 'Hello world'`, `end`],
          config: {
            isNotebook: true,
          },
        },
        {
          name: 'ignores compile opt idl2 for functions',
          code: [
            `function myPro`,
            `  print, 'Hello world'`,
            `  return 42`,
            `end`,
          ],
          config: {
            isNotebook: true,
          },
        },
      ],
    },
    {
      suiteName: `Only use code for docs`,
      fileName: `only-from-code.spec.ts`,
      tests: [
        {
          name: 'and exclude incorrectly documented parameters',
          code: [
            `;+`,
            `; Header`,
            `;`,
            `; :Args:`,
            `;   a: in, required, int`,
            `;     Some cool statement across`,
            `;`,
            `;     multiple lines`,
            `;   b: in, required, string`,
            `;     Some cool statement across`,
            `;`,
            `;     multiple lines`,
            `; :Keywords:`,
            `;   kw1: in, required, int`,
            `;     Some cool statement across`,
            `;`,
            `;     multiple lines`,
            `;   kw2: in, required, string`,
            `;     Some cool statement across`,
            `;`,
            `;     multiple lines`,
            `;`,
            `; :Author: Meeeeeeeeeeeeeeeeeee`,
            ``,
            ``,
            ``,
            ``,
            `pro myPro, a, kw1 = kw1`,
            ``,
            ``,
            ` print, 'Hello world'`,
            ``,
            ``,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Verify fast parsing ignores docs`,
      fileName: `parse-fast.ignore-docs.1.spec.ts`,
      tests: [
        {
          name: 'for structures',
          code: [
            `;+`,
            `; :MyStruct:`,
            `;   prop: Long`,
            `;     Placeholder docs for argument or keyword`,
            `;   prop2: ENVIRaster`,
            `;     Placeholder docs for argument or keyword`,
            `;`,
            `;-`,
            `pro mystruct__define`,
            `  compile_opt idl2`,
            ``,
            `  !null = {MyStruct, inherits IDL_object, prop: 1, prop2: 4}`,
            ``,
            `end`,
          ],
          config: {
            full: false,
          },
        },
      ],
    },
    {
      suiteName: `Verify fast parsing ignores docs`,
      fileName: `parse-fast.ignore-docs.2.spec.ts`,
      tests: [
        {
          name: `for procedures`,
          code: [
            `;+`,
            `; :Arguments:`,
            `;   arg1: in, required, envitask`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   arg2: in, required, idltask`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   arg3: in, required, ENVITask<buildmosaicraster> | ENVITask<SubsetRaster>`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   arg4: in, required, IDLTask<S3_Download>`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   arg5: in, required, ENVITask<BuildMosaicRaster | SubsetRaster>`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;`,
            `;-`,
            `pro pro3, arg1, arg2, arg3, arg4, arg5, KW1 = kw1`,
            `  compile_opt idl3`,
            ``,
            `end`,
          ],
          config: {
            full: false,
          },
        },
      ],
    },
    {
      suiteName: `Verify fast parsing ignores docs`,
      fileName: `parse-fast.ignore-docs.3.spec.ts`,
      tests: [
        {
          name: `for functions`,
          code: [
            `;+`,
            `; :Arguments:`,
            `;   arg1: in, required, envitask`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   arg2: in, required, idltask`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   arg3: in, required, ENVITask<buildmosaicraster> | ENVITask<SubsetRaster>`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   arg4: in, required, IDLTask<S3_Download>`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   arg5: in, required, ENVITask<BuildMosaicRaster | SubsetRaster>`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;`,
            `;-`,
            `function myfunc, arg1, arg2, arg3, arg4, arg5, KW1 = kw1`,
            `  compile_opt idl3`,
            `  return, 42`,
            `end`,
          ],
          config: {
            full: false,
          },
        },
      ],
    },
    {
      suiteName: `Correctly populate structures`,
      fileName: `populate-structures.1.spec.ts`,
      tests: [
        {
          name: 'in class definitions',
          code: [
            `pro mystruct__define`,
            `  compile_opt idl2`,
            ``,
            `  !null = {MyStruct, inherits IDL_object, prop: 1, prop2: 4}`,
            ``,
            `  !null = {mystruct2, inherits IDL_object, prop: 1, prop2: 4}`,
            `end`,
          ],
        },
        {
          name: 'with no properties',
          code: [
            `pro mystruct__define`,
            `  compile_opt idl2`,
            ``,
            `  !null = {MyStruct}`,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Use docs for property types`,
      fileName: `populate-structures.2.spec.ts`,
      tests: [
        {
          name: 'in structures',
          code: [
            `;+`,
            `; :MyStruct:`,
            `;   prop: Long`,
            `;     Placeholder docs for argument or keyword`,
            `;   prop2: ENVIRaster`,
            `;     Placeholder docs for argument or keyword`,
            `;`,
            `;-`,
            `pro mystruct__define`,
            `  compile_opt idl2`,
            ``,
            `  !null = {MyStruct, inherits IDL_object, prop: 1, prop2: 4}`,
            ``,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Find them in`,
      fileName: `populate-structures.3.spec.ts`,
      tests: [
        {
          name: 'normal procedures',
          code: [
            `pro define_these_structures`,
            `compile_opt idl2`,
            `fhdr = {WAVFILEHEADER, $`,
            `  friff: bytarr(4), $ ; A four char string`,
            `  fsize: 0ul, $`,
            `  fwave: bytarr(4) $ ; A four char string`,
            `}`,
            ``,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Find them in`,
      fileName: `populate-structures.4.spec.ts`,
      tests: [
        {
          name: 'normal functions',
          code: [
            `function define_these_structures`,
            `compile_opt idl2`,
            `fhdr = {WAVFILEHEADER, $`,
            `  friff: bytarr(4), $ ; A four char string`,
            `  fsize: 0ul, $`,
            `  fwave: bytarr(4) $ ; A four char string`,
            `}`,
            `return, 1`,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Find them in`,
      fileName: `populate-structures.5.spec.ts`,
      tests: [
        {
          name: 'procedure methods',
          code: [
            `pro define_these_structures::method`,
            `compile_opt idl2`,
            `fhdr = {WAVFILEHEADER, $`,
            `  friff: bytarr(4), $ ; A four char string`,
            `  fsize: 0ul, $`,
            `  fwave: bytarr(4) $ ; A four char string`,
            `}`,
            ``,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Find them in`,
      fileName: `populate-structures.6.spec.ts`,
      tests: [
        {
          name: 'function methods',
          code: [
            `function define_these_structures::method`,
            `compile_opt idl2`,
            `fhdr = {WAVFILEHEADER, $`,
            `  friff: bytarr(4), $ ; A four char string`,
            `  fsize: 0ul, $`,
            `  fwave: bytarr(4) $ ; A four char string`,
            `}`,
            `return, 1`,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Ignore them in`,
      fileName: `populate-structures.7.spec.ts`,
      tests: [
        {
          name: 'procedures',
          code: [
            `pro my_def__define`,
            `compile_opt idl2`,
            `fhdr = {WAVFILEHEADER, $`,
            `  friff: bytarr(4), $ ; A four char string`,
            `  fsize: 0ul, $`,
            `  fwave: bytarr(4) $ ; A four char string`,
            `}`,
            ``,
            `if ~_exists then defsysv, '!notebook_magic', {IDLNotebookMagic}`,
            ``,
            `end`,
          ],
        },
        {
          name: 'as nested properties',
          code: [
            `pro my_def__define`,
            `compile_opt idl2`,
            `fhdr = {WAVFILEHEADER, $`,
            `  friff: bytarr(4), $ ; A four char string`,
            `  fsize: 0ul, $`,
            `  fwave: bytarr(4) $ ; A four char string`,
            `}`,
            ``,
            `!null = {OtherStruct, prop:{SecondOtherStruct}}`,
            ``,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Take first instance we encounter`,
      fileName: `populate-structures.8.spec.ts`,
      tests: [
        {
          name: 'with non-full parse',
          code: [
            `pro my_def__define`,
            `compile_opt idl2`,
            `fhdr = {WAVFILEHEADER, $`,
            `  friff: bytarr(4), $ ; A four char string`,
            `  fsize: 0ul, $`,
            `  fwave: bytarr(4) $ ; A four char string`,
            `}`,
            ``,
            `if ~_exists then defsysv, '!notebook_magic', {WAVFILEHEADER}`,
            ``,
            `end`,
          ],
          config: {
            full: false,
          },
        },
      ],
    },
    {
      suiteName: `Correctly extract variables from`,
      fileName: `procedures.spec.ts`,
      tests: [
        {
          name: 'procedures',
          code: [
            `pro mypro, arg1, arg2, arg3, KW1=kw1,$ ; commment`,
            `  KW2 = kw2, KW3 = kw3`,
            `  compile_opt idl2`,
            ``,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Correctly extract variables from`,
      fileName: `procedure-methods.spec.ts`,
      tests: [
        {
          name: 'procedure methods',
          code: [
            `pro myclass::mymethod, arg1, arg2, arg3, KW1=kw1,$ ; commment`,
            `  KW2 = kw2, KW3 = kw3`,
            `  compile_opt idl2`,
            ``,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Verify type parsing for`,
      fileName: `tasks.from-docs.spec.ts`,
      tests: [
        {
          name: `ENVI and IDL Tasks in docs`,
          code: [
            `;+`,
            `; :Arguments:`,
            `;   arg1: in, required, envitask`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   arg2: in, required, idltask`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   arg3: in, required, ENVITask<buildmosaicraster> | ENVITask<SubsetRaster>`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   arg4: in, required, IDLTask<S3_Download>`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   arg5: in, required, ENVITask<BuildMosaicRaster | SubsetRaster>`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;`,
            `;-`,
            `pro pro3, arg1, arg2, arg3, arg4, arg5`,
            `  compile_opt idl3`,
            ``,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Verify behaviors for task types`,
      fileName: `tasks.guessing-from-code.spec.ts`,
      tests: [
        {
          name: `where we determine types from code`,
          code: [
            `compile_opt idl2`,
            ``,
            `mosaic1 = ENVITask('BuildMosaicRaster')`,
            `mosaic2 = ENVITask(routine_dir() + 'buildmosaicraster.task')`,
            ``,
            `uri = 'buildmosaicraster.task'`,
            `mosaic3 = ENVITask(uri)`,
            ``,
            `envitaskany1 = ENVITask(uri + uri)`,
            ``,
            `idlmosaic1 = IDLTask('BuildMosaicRaster')`,
            `idlmosaic2 = IDLTask(routine_dir() + 'buildmosaicraster.task')`,
            ``,
            `idlmosaic3 = IDLTask(uri)`,
            ``,
            `idltaskany1 = IDLTask(uri + uri)`,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Types from output arguments`,
      fileName: `types.from-args.spec.ts`,
      tests: [
        {
          name: 'and exclude incorrectly documented parameters',
          code: [
            `;+`,
            `; :Arguments:`,
            `;   a: in, required, ENVIRaster`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   b: out, required, Long`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   c: out, required, ENVIRaster`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;`,
            `;-`,
            `pro auto_doc_example, a, b, c`,
            `  compile_opt idl2`,
            ``,
            `end`,
            ``,
            `; main level`,
            `compile_opt idl2`,
            `auto_doc_example, arg1, arg2, arg3`,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Types from assignment`,
      fileName: `types.from-assignment-weird.spec.ts`,
      tests: [
        {
          name: 'where we define vars in-line',
          code: [
            `; main level`,
            `compile_opt idl2`,
            ``,
            `; any because using var before defined`,
            `c = d + (d = 5)`,
            ``,
            `; number`,
            `f = (g = 6) + g`,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Types from`,
      fileName: `types.arrays.brackets.spec.ts`,
      tests: [
        {
          name: `array creation using brackets`,
          code: [
            `pro array_creation`,
            `  compile_opt idl2`,
            ``,
            `  ; long`,
            `  a = [1, 2, 3, 4]`,
            ``,
            `  ; float`,
            `  b = [1, 2, 3, 4.]`,
            ``,
            `  ; double`,
            `  c = [1, 2, 3, 4d]`,
            ``,
            `  ; complex double`,
            `  d = [1, 2, 3, 4di]`,
            ``,
            `  ; invalid`,
            `  e = [1, 2, 3, plot()]`,
            ``,
            `  ; ignore if element has Null`,
            `  f = [1, 2, 3, !null, 4, 5]`,
            ``,
            `  ; no nested arrays, just promoted`,
            `  g = [1, 2, 3, [1, 2, 3, 4d], 4, 5]`,
            ``,
            `  ; array of lists`,
            `  h = [list(), list()]`,
            ``,
            `  ; array of ENVIRasters`,
            `  i = [ENVIRaster(), ENVIRaster()]`,
            ``,
            `  ; array of any`,
            `  j = [ENVIRaster(), plot()]`,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Types from`,
      fileName: `types.arrays.edge-cases.spec.ts`,
      tests: [
        {
          name: `array creation using edge cases that failed`,
          code: [
            `pro array_creation`,
            `  compile_opt idl2`,
            ``,
            `  ; array of number`,
            `  a = [where(x)]`,
            `end`,
          ],
        },
        {
          name: `scalars or arrays can be used interchangeably`,
          code: [
            `pro array_creation`,
            `  compile_opt idl2`,
            `  e = envi()`,
            `  r = e.openRaster() ; scalar or array ENVIRaster`,
            `  ; array of ENVIRaster`,
            `  arr = [r]`,
            `end`,
          ],
        },
        {
          name: `allow all objects as long as no structures or all structures`,
          code: [
            `pro array_creation`,
            `  compile_opt idl2`,
            `  arr1 = [ENVIRaster(), ENVIMetaspectralRaster(), ENVISubsetRaster()]`,
            `  arr2 = [{}, {}]`,
            ``,
            `  bad = [ENVIRaster(), ENVIMetaspectralRaster(), ENVISubsetRaster(), {}, 1]`,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Types from`,
      fileName: `types.array-promotion.spec.ts`,
      tests: [
        {
          name: `array promotion`,
          code: [
            `;+`,
            `; :Returns: ArrayPromotion<String>`,
            `;`,
            `; :Arguments:`,
            `;   a: bidirectional, required, any`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;`,
            `;-`,
            `function test, a`,
            `  compile_opt idl2`,
            ``,
            `  return, 1`,
            `end`,
            ``,
            `compile_opt idl2`,
            ``,
            `; scalars`,
            `scalar1 = test(1)`,
            ``,
            `; arrays`,
            `array1 = test([1])`,
            `array2 = test(bytarr(5))`,
            ``,
            `; either scalar or array`,
            `c = made_up()`,
            `either = test(c)`,
            ``,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Types from foreach loop`,
      fileName: `types.from-foreach.spec.ts`,
      tests: [
        {
          name: 'with type args 1',
          code: [
            `;+`,
            `; :Arguments:`,
            `;   item: in, required, List<Number>`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;-`,
            `pro foreach, item`,
            `  compile_opt idl2`,

            `  ; item is bad`,
            `  foreach val, item, key do print, val`,
            `end`,
          ],
        },
        {
          name: 'with type args 2',
          code: [
            `;+`,
            `; :Arguments:`,
            `;   item: in, required, Array<Number | String>`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;-`,
            `pro foreach, item`,
            `  compile_opt idl2`,

            `  ; item is bad`,
            `  foreach val, item, key do print, val`,
            `end`,
          ],
        },
        {
          name: 'with non-index types returning original 1',
          code: [
            `;+`,
            `; :Arguments:`,
            `;   item: in, required, String`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;-`,
            `pro foreach, item`,
            `  compile_opt idl2`,

            `  ; item is bad`,
            `  foreach val, item, key do print, val`,
            `end`,
          ],
        },
        {
          name: 'with non-index types returning original 2',
          code: [
            `;+`,
            `; :Arguments:`,
            `;   item: in, required, Number`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;-`,
            `pro foreach, item`,
            `  compile_opt idl2`,

            `  ; item is bad`,
            `  foreach val, item, key do print, val`,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Types from foreach loop regression tests`,
      fileName: `types.from-foreach.regression1.spec.ts`,
      tests: [
        {
          name: 'with bad syntax',
          code: [
            `pro `,
            `;+`,
            `; :Arguments:`,
            `;   item: in, required, List<Number>`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;-`,
            `pro foreach, item`,
            `  compile_opt idl2`,

            `  ; item is bad`,
            `  foreach val, item, key do print, val`,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Types from`,
      fileName: `types.from-functions.spec.ts`,
      tests: [
        {
          name: 'functions',
          code: [
            `pro myPro`,
            `  compile_opt idl2`,
            ``,
            `  a = ENVISubsetRaster()`,
            ``,
            `  b = ENVITask('subsetraster')`,
            ``,
            `  c = obj_new('envitask')`,
            ``,
            `  d = keyword_set(5)`,
            ``,
            `  e = dictionary()`,
            ``,
            `  f = ENVITensorFlowModel()`,
            ``,
            `  g = IDLTask('MyTask')`,
            ``,
            `end`,
          ],
        },
        {
          name: 'functions with other strings',
          code: [
            `pro myPro`,
            `  compile_opt idl2`,
            ``,
            `  a = ENVITask("subsetraster")`,
            ``,
            `  b = ENVITask(\`subsetraster\`)`,
            ``,
            `  c = obj_new("envitask")`,
            ``,
            `  d = obj_new(\`envitask\`)`,
            ``,
            `  e = IDLTask("MyTask")`,
            ``,
            `  f = IDLTask(\`MyTask\`)`,
            ``,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Types from`,
      fileName: `types.from-numbers.spec.ts`,
      tests: [
        {
          name: 'numbers',
          code: [
            `pro pro4`,
            `compile_opt idl2`,
            ``,
            `; byte`,
            `byte1 = 0b`,
            `byte2 = 0ub`,
            ``,
            `; integer`,
            `int1 = 0s`,
            ``,
            `; compile option`,
            `compOptLong = 0`,
            ``,
            `; uint`,
            `uint1 = 0u`,
            `uint2 = 0us`,
            ``,
            `; long`,
            `long1 = 0l`,
            ``,
            `; ulong`,
            `ulong1 = 0ul`,
            ``,
            `; long64`,
            `long641 = 0ll`,
            ``,
            `; ulong64`,
            `ulong641 = 0ull`,
            ``,
            `; float`,
            `float1 = 1.`,
            `float2 = .1`,
            `float3 = 1.1`,
            `float4 = 10e`,
            `float5 = 10e5`,
            `float6 = 10.e-3`,
            `float7 = .1e+12`,
            `float8 = 2.3e12`,
            ``,
            `; double`,
            `double0 = 1d`,
            `double1 = 1.d`,
            `double2 = .1d`,
            `double3 = 1.1d`,
            `double4 = 10d`,
            `double5 = 10d5`,
            `double6 = 10.d-3`,
            `double7 = .1d+12`,
            `double8 = 2.3d12`,
            ``,
            `; binary`,
            `binary1 = '10101'b`,
            `binary2 = "10101"b`,
            ``,
            `; hex`,
            `hex1 = '10101'x`,
            `hex2 = '7FFF'XS`,
            `hex3 = '8FFF'XS`,
            `hex4 = "10101"x`,
            `hex5 = 0x`,
            `hex6 = 0x7FFF`,
            ``,
            `; octal`,
            `octal1 = "36`,
            `octal2 = "36b`,
            `octal3 = "345ull`,
            `octal4 = '10101'o`,
            `octal5 = "10101"o`,
            `octal6 = 0o`,
            `octal7 = 0o7FFF`,
            `end`,
          ],
        },
        {
          name: 'numbers with no compile opt',
          code: [
            `pro pro1`,
            `compile_opt`,
            `; compile option`,
            `compOptInt = 0`,
            `end`,
          ],
        },
        {
          name: 'numbers with float64 compile opt',
          code: [
            `pro pro2`,
            `compile_opt float64`,
            `; compile option`,
            `compOptDouble = 0`,
            ``,
            `; float`,
            `float1 = 1.`,
            `float2 = .1`,
            `float3 = 1.1`,
            `float4 = 10e`,
            `float5 = 10e5`,
            `float6 = 10.e-3`,
            `float7 = .1e+12`,
            `float8 = 2.3e12`,
            `end`,
          ],
        },
        {
          name: 'numbers with idl3 compile opt',
          code: [
            `pro pro3`,
            `compile_opt idl3`,
            `; compile option`,
            `compOptDouble = 0`,
            ``,
            `; float`,
            `float1 = 1.`,
            `float2 = .1`,
            `float3 = 1.1`,
            `float4 = 10e`,
            `float5 = 10e5`,
            `float6 = 10.e-3`,
            `float7 = .1e+12`,
            `float8 = 2.3e12`,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Types from`,
      fileName: `types.from-numbers-complex1.spec.ts`,
      tests: [
        {
          name: 'complex numbers using "i"',
          code: [
            `pro pro5`,
            `compile_opt idl2`,
            ``,
            `; byte`,
            `byte1 = 0bi`,
            `byte2 = 0ubi`,
            ``,
            `; integer`,
            `int1 = 0si`,
            ``,
            `; compile option`,
            `compOptLong = 0i`,
            ``,
            `; uint`,
            `uint1 = 0ui`,
            `uint2 = 0usi`,
            ``,
            `; long`,
            `long1 = 0li`,
            ``,
            `; ulong`,
            `ulong1 = 0uli`,
            ``,
            `; long64`,
            `long641 = 0lli`,
            ``,
            `; ulong64`,
            `ulong641 = 0ulli`,
            ``,
            `; float`,
            `float1 = 1.i`,
            `float2 = .1i`,
            `float3 = 1.1i`,
            `float4 = 10ei`,
            `float5 = 10e5i`,
            `float6 = 10.e-3i`,
            `float7 = .1e+12i`,
            `float8 = 2.3e12i`,
            ``,
            `; double`,
            `double0 = 1di`,
            `double1 = 1.di`,
            `double2 = .1di`,
            `double3 = 1.1di`,
            `double4 = 10di`,
            `double5 = 10d5i`,
            `double6 = 10.d-3i`,
            `double7 = .1d+12i`,
            `double8 = 2.3d12i`,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Types from`,
      fileName: `types.from-numbers-complex2.spec.ts`,
      tests: [
        {
          name: 'complex numbers using "j"',
          code: [
            `pro pro6`,
            `compile_opt idl2`,
            ``,
            `; byte`,
            `byte1 = 0bj`,
            `byte2 = 0ubj`,
            ``,
            `; jnteger`,
            `jnt1 = 0sj`,
            ``,
            `; compjle optjon`,
            `compOptLong = 0j`,
            ``,
            `; ujnt`,
            `ujnt1 = 0uj`,
            `ujnt2 = 0usj`,
            ``,
            `; long`,
            `long1 = 0lj`,
            ``,
            `; ulong`,
            `ulong1 = 0ulj`,
            ``,
            `; long64`,
            `long641 = 0llj`,
            ``,
            `; ulong64`,
            `ulong641 = 0ullj`,
            ``,
            `; float`,
            `float1 = 1.j`,
            `float2 = .1j`,
            `float3 = 1.1j`,
            `float4 = 10ej`,
            `float5 = 10e5j`,
            `float6 = 10.e-3j`,
            `float7 = .1e+12j`,
            `float8 = 2.3e12j`,
            ``,
            `; double`,
            `double0 = 1dj`,
            `double1 = 1.dj`,
            `double2 = .1dj`,
            `double3 = 1.1dj`,
            `double4 = 10dj`,
            `double5 = 10d5j`,
            `double6 = 10.d-3j`,
            `double7 = .1d+12j`,
            `double8 = 2.3d12j`,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Types from`,
      fileName: `types.from-properties.spec.ts`,
      tests: [
        {
          name: 'properties',
          code: [
            `;+`,
            `; :Arguments:`,
            `;   a: in, required, ENVIRaster`,
            `;     Placeholder docs for argument or keyword`,
            `;`,
            `;-`,
            `pro pro4, a`,
            `  compile_opt idl2`,
            ``,
            `  ; properties`,
            `  p1 = a.metadata`,
            `  p2 = p1.count`,
            `  p3 = (a.metadata)`,
            `  p4 = a.metadata.count`,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Types from`,
      fileName: `types.from-properties2.spec.ts`,
      tests: [
        {
          name: 'properties of anonymous structures',
          code: [
            `pro pro4`,
            `  compile_opt idl2`,
            `  a = {a: 'string', $`,
            `    b: \`string\`}`,
            ``,
            `  ; properties`,
            `  p1 = a.a`,
            `  p2 = p1.length`,
            `  p3 = (a.b)`,
            `  p4 = a.b`,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Types from`,
      fileName: `types.from-type-of-arg.spec.ts`,
      tests: [
        {
          name: 'type-of-arg case without args (default to first)',
          code: [
            `;+`,
            `; :Returns: TypeOfArg`,
            `;`,
            `;-`,
            `function myfunc`,
            `  compile_opt idl2`,
            ``,
            `  return, 1`,
            `end`,
            ``,
            `; main level`,
            `compile_opt idl2`,
            ``,
            `string = myfunc('string')`,
            `any = myfunc()`,
            `float = myfunc(1.0)`,
            `array = myfunc([1, 2, 3])`,
            `end`,
          ],
        },
        {
          name: 'type-of-arg case specifying arg',
          code: [
            `;+`,
            `; :Returns: TypeOfArg<0>`,
            `;`,
            `;-`,
            `function myfunc`,
            `  compile_opt idl2`,
            ``,
            `  return, 1`,
            `end`,
            ``,
            `; main level`,
            `compile_opt idl2`,
            ``,
            `string = myfunc('string')`,
            `any = myfunc()`,
            `float = myfunc(1.0)`,
            `array = myfunc([1, 2, 3])`,
            `end`,
          ],
        },
        {
          name: 'type-of-arg case invalid arg uses any',
          code: [
            `;+`,
            `; :Returns: TypeOfArg<2>`,
            `;`,
            `;-`,
            `function myfunc`,
            `  compile_opt idl2`,
            ``,
            `  return, 1`,
            `end`,
            ``,
            `; main level`,
            `compile_opt idl2`,
            ``,
            `string = myfunc('string')`,
            `any = myfunc()`,
            `float = myfunc(1.0)`,
            `array = myfunc([1, 2, 3])`,
            `end`,
          ],
        },
        {
          name: 'type-of-arg case non-number index',
          code: [
            `;+`,
            `; :Returns: TypeOfArg<baad>`,
            `;`,
            `;-`,
            `function myfunc`,
            `  compile_opt idl2`,
            ``,
            `  return, 1`,
            `end`,
            ``,
            `; main level`,
            `compile_opt idl2`,
            ``,
            `string = myfunc('string')`,
            `any = myfunc()`,
            `float = myfunc(1.0)`,
            `array = myfunc([1, 2, 3])`,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Types from`,
      fileName: `types.from-type-args.edge-cases1.spec.ts`,
      tests: [
        {
          name: 'type without type args',
          code: [
            `;+`,
            `; :Arguments:`,
            `;   item: in, required, List<>`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;-`,
            `pro foreach, item`,
            `  compile_opt idl2`,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Types from`,
      fileName: `types.indexing.arrays.spec.ts`,
      tests: [
        {
          name: 'indexing arrays',
          code: [
            `;+`,
            `; :Returns:`,
            `;   Number`,
            `;`,
            `;-`,
            `function myfunc`,
            `  compile_opt idl2`,
            ``,
            `  return, 1`,
            `end`,
            ``,
            `;+`,
            `; :Returns:`,
            `;   Array<Number>`,
            `;`,
            `;-`,
            `function myfunc2`,
            `  compile_opt idl2`,
            ``,
            `  return, 1`,
            `end`,
            ``,
            `;+`,
            `; :Arguments:`,
            `;   arg1: in, required, Array<Number | String>`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   arg2: in, required, Array<Number>`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   arg3: in, required, Array<any>`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   arg4: in, required, Array<Byte>`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   arg5: in, required, Array<ENVIRaster>`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   arg6: in, required, any`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;`,
            `;-`,
            `pro arrays, arg1, arg2, arg3, arg4, arg5, arg6`,
            `  compile_opt idl3`,
            ``,
            `  ; type args`,
            `  c = arg1[0]`,
            ``,
            `  ; return array of type args`,
            `  d = arg1[arg2]`,
            ``,
            `  ; return array`,
            `  e = arg1[*]`,
            ``,
            `  ; return array`,
            `  f = arg1[0, 1, *]`,
            ``,
            `  ; return type args`,
            `  g = arg1[myfunc()]`,
            ``,
            `  ; return array`,
            `  h = arg1[myfunc2()]`,
            ``,
            `  ; type args`,
            `  i = arg1[0, 1, 2]`,
            ``,
            `  ; return array`,
            `  j = arg1[0, 1, myfunc2()]`,
            ``,
            `  ; return array`,
            `  k = arg1[0 : -1 : 1]`,
            ``,
            `  ; return array`,
            `  l = arg1[0, 1, *]`,
            ``,
            `  ; return type args`,
            `  m = arg1[-1]`,
            ``,
            `  ; any`,
            `  n = arg3[0]`,
            ``,
            `  ; array of any`,
            `  o = arg3[myfunc2()]`,
            ``,
            `  ; return array`,
            `  p = arg1[0, myfunc2(), 1]`,
            ``,
            `  ; return array`,
            `  q = arg1[[1, 2, 3]]`,
            ``,
            `  ; return type args`,
            `  r = arg1[1 + 2]`,
            ``,
            `  ; return array`,
            `  s = arg1[1 + myfunc2()]`,
            ``,
            `  ; return any`,
            `  t = arg1[plot()]`,
            ``,
            `  ; return any`,
            `  u = arg1[1j]`,
            ``,
            `  ; return any`,
            `  v = arg1[1i]`,
            ``,
            `  ; return any`,
            `  w = arg1[1di]`,
            ``,
            `  ; return any`,
            `  x = arg1[1dj]`,
            ``,
            `  ; merge type args`,
            `  y = arg1 + arg3`,
            ``,
            `  ; merge type args`,
            `  z = arg1 + arg4 + 1l`,
            ``,
            `  ; merge type args`,
            `  a2 = arg1 + arg4 + 1`,
            ``,
            `  ; merge type args`,
            `  b2 = arg1 + arg4 + arg5`,
            ``,
            `  ; any`,
            `  c2 = arg1[arg6]`,
            ``,
            `  ; any`,
            `  d2 = arg1 + arg4 + arg6`,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Types from`,
      fileName: `types.indexing.dictionaries.spec.ts`,
      tests: [
        {
          name: 'dictionaries',
          code: [
            `;+`,
            `; :Returns:`,
            `;   Number`,
            `;`,
            `;-`,
            `function myfunc`,
            `  compile_opt idl2`,
            ``,
            `  return, 1`,
            `end`,
            ``,
            `;+`,
            `; :Returns:`,
            `;   Array<Number>`,
            `;`,
            `;-`,
            `function myfunc2`,
            `  compile_opt idl2`,
            ``,
            `  return, 1`,
            `end`,
            ``,
            `;+`,
            `; :Arguments:`,
            `;   arg1: in, required, Dictionary<Number | String>`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   arg2: in, required, Array<Number>`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   arg3: in, required, Array<any>`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   arg4: in, required, Array<Byte>`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   arg5: in, required, Array<ENVIRaster>`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   arg6: in, required, any`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;`,
            `;-`,
            `pro dictionaries, arg1, arg2, arg3, arg4, arg5, arg6`,
            `  compile_opt idl3`,
            ``,
            `  ; type args`,
            `  c = arg1[0]`,
            ``,
            `  ; return array of type args`,
            `  d = arg1[arg2]`,
            ``,
            `  ; return array`,
            `  e = arg1[*]`,
            ``,
            `  ; return array`,
            `  f = arg1[0, 1, *]`,
            ``,
            `  ; return type args`,
            `  g = arg1[myfunc()]`,
            ``,
            `  ; return array`,
            `  h = arg1[myfunc2()]`,
            ``,
            `  ; type args`,
            `  i = arg1[0, 1, 2]`,
            ``,
            `  ; return array`,
            `  j = arg1[0, 1, myfunc2()]`,
            ``,
            `  ; return array`,
            `  k = arg1[0 : -1 : 1]`,
            ``,
            `  ; return array`,
            `  l = arg1[0, 1, *]`,
            ``,
            `  ; return type args`,
            `  m = arg1[-1]`,
            ``,
            `  ; any`,
            `  n = arg3[0]`,
            ``,
            `  ; array of any`,
            `  o = arg3[myfunc2()]`,
            ``,
            `  ; return array`,
            `  p = arg1[0, myfunc2(), 1]`,
            ``,
            `  ; return array`,
            `  q = arg1[[1, 2, 3]]`,
            ``,
            `  ; return type args`,
            `  r = arg1[1 + 2]`,
            ``,
            `  ; return array`,
            `  s = arg1[1 + myfunc2()]`,
            ``,
            `  ; return any`,
            `  t = arg1[plot()]`,
            ``,
            `  ; return any`,
            `  u = arg1[1j]`,
            ``,
            `  ; return any`,
            `  v = arg1[1i]`,
            ``,
            `  ; return any`,
            `  w = arg1[1di]`,
            ``,
            `  ; return any`,
            `  x = arg1[1dj]`,
            ``,
            `  ; merge type args`,
            `  y = arg1 + arg3`,
            ``,
            `  ; merge type args`,
            `  z = arg1 + arg4 + 1l`,
            ``,
            `  ; merge type args`,
            `  a2 = arg1 + arg4 + 1`,
            ``,
            `  ; merge type args`,
            `  b2 = arg1 + arg4 + arg5`,
            ``,
            `  ; any`,
            `  c2 = arg1[arg6]`,
            ``,
            `  ; any`,
            `  d2 = arg1 + arg4 + arg6`,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Types from`,
      fileName: `types.indexing.hashes.spec.ts`,
      tests: [
        {
          name: 'hashes',
          code: [
            `;+`,
            `; :Returns:`,
            `;   Number`,
            `;`,
            `;-`,
            `function myfunc`,
            `  compile_opt idl2`,
            ``,
            `  return, 1`,
            `end`,
            ``,
            `;+`,
            `; :Returns:`,
            `;   Array<Number>`,
            `;`,
            `;-`,
            `function myfunc2`,
            `  compile_opt idl2`,
            ``,
            `  return, 1`,
            `end`,
            ``,
            `;+`,
            `; :Arguments:`,
            `;   arg1: in, required, Hash<Number | String>`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   arg2: in, required, Array<Number>`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   arg3: in, required, Array<any>`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   arg4: in, required, Array<Byte>`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   arg5: in, required, Array<ENVIRaster>`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   arg6: in, required, any`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;`,
            `;-`,
            `pro pro34, arg1, arg2, arg3, arg4, arg5, arg6`,
            `  compile_opt idl3`,
            ``,
            `  ; type args`,
            `  c = arg1[0]`,
            ``,
            `  ; return array of type args`,
            `  d = arg1[arg2]`,
            ``,
            `  ; return array`,
            `  e = arg1[*]`,
            ``,
            `  ; return array`,
            `  f = arg1[0, 1, *]`,
            ``,
            `  ; return type args`,
            `  g = arg1[myfunc()]`,
            ``,
            `  ; return array`,
            `  h = arg1[myfunc2()]`,
            ``,
            `  ; type args`,
            `  i = arg1[0, 1, 2]`,
            ``,
            `  ; return array`,
            `  j = arg1[0, 1, myfunc2()]`,
            ``,
            `  ; return array`,
            `  k = arg1[0 : -1 : 1]`,
            ``,
            `  ; return array`,
            `  l = arg1[0, 1, *]`,
            ``,
            `  ; return type args`,
            `  m = arg1[-1]`,
            ``,
            `  ; any`,
            `  n = arg3[0]`,
            ``,
            `  ; array of any`,
            `  o = arg3[myfunc2()]`,
            ``,
            `  ; return array`,
            `  p = arg1[0, myfunc2(), 1]`,
            ``,
            `  ; return array`,
            `  q = arg1[[1, 2, 3]]`,
            ``,
            `  ; return type args`,
            `  r = arg1[1 + 2]`,
            ``,
            `  ; return array`,
            `  s = arg1[1 + myfunc2()]`,
            ``,
            `  ; return any`,
            `  t = arg1[plot()]`,
            ``,
            `  ; return any`,
            `  u = arg1[1j]`,
            ``,
            `  ; return any`,
            `  v = arg1[1i]`,
            ``,
            `  ; return any`,
            `  w = arg1[1di]`,
            ``,
            `  ; return any`,
            `  x = arg1[1dj]`,
            ``,
            `  ; merge type args`,
            `  y = arg1 + arg3`,
            ``,
            `  ; merge type args`,
            `  z = arg1 + arg4 + 1l`,
            ``,
            `  ; merge type args`,
            `  a2 = arg1 + arg4 + 1`,
            ``,
            `  ; merge type args`,
            `  b2 = arg1 + arg4 + arg5`,
            ``,
            `  ; any`,
            `  c2 = arg1[arg6]`,
            ``,
            `  ; any`,
            `  d2 = arg1 + arg4 + arg6`,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Types from`,
      fileName: `types.indexing.lists.spec.ts`,
      tests: [
        {
          name: 'lists',
          code: [
            `;+`,
            `; :Returns:`,
            `;   Number`,
            `;`,
            `;-`,
            `function myfunc`,
            `  compile_opt idl2`,
            ``,
            `  return, 1`,
            `end`,
            ``,
            `;+`,
            `; :Returns:`,
            `;   Array<Number>`,
            `;`,
            `;-`,
            `function myfunc2`,
            `  compile_opt idl2`,
            ``,
            `  return, 1`,
            `end`,
            ``,
            `;+`,
            `; :Arguments:`,
            `;   arg1: in, required, List<Number | String>`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   arg2: in, required, Array<Number>`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   arg3: in, required, Array<any>`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   arg4: in, required, Array<Byte>`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   arg5: in, required, Array<ENVIRaster>`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   arg6: in, required, any`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;`,
            `;-`,
            `pro lists, arg1, arg2, arg3, arg4, arg5, arg6`,
            `  compile_opt idl3`,
            ``,
            `  ; type args`,
            `  c = arg1[0]`,
            ``,
            `  ; return array of type args`,
            `  d = arg1[arg2]`,
            ``,
            `  ; return array`,
            `  e = arg1[*]`,
            ``,
            `  ; return array`,
            `  f = arg1[0, 1, *]`,
            ``,
            `  ; return type args`,
            `  g = arg1[myfunc()]`,
            ``,
            `  ; return array`,
            `  h = arg1[myfunc2()]`,
            ``,
            `  ; type args`,
            `  i = arg1[0, 1, 2]`,
            ``,
            `  ; return array`,
            `  j = arg1[0, 1, myfunc2()]`,
            ``,
            `  ; return array`,
            `  k = arg1[0 : -1 : 1]`,
            ``,
            `  ; return array`,
            `  l = arg1[0, 1, *]`,
            ``,
            `  ; return type args`,
            `  m = arg1[-1]`,
            ``,
            `  ; any`,
            `  n = arg3[0]`,
            ``,
            `  ; array of any`,
            `  o = arg3[myfunc2()]`,
            ``,
            `  ; return array`,
            `  p = arg1[0, myfunc2(), 1]`,
            ``,
            `  ; return array`,
            `  q = arg1[[1, 2, 3]]`,
            ``,
            `  ; return type args`,
            `  r = arg1[1 + 2]`,
            ``,
            `  ; return array`,
            `  s = arg1[1 + myfunc2()]`,
            ``,
            `  ; return any`,
            `  t = arg1[plot()]`,
            ``,
            `  ; return any`,
            `  u = arg1[1j]`,
            ``,
            `  ; return any`,
            `  v = arg1[1i]`,
            ``,
            `  ; return any`,
            `  w = arg1[1di]`,
            ``,
            `  ; return any`,
            `  x = arg1[1dj]`,
            ``,
            `  ; merge type args`,
            `  y = arg1 + arg3`,
            ``,
            `  ; merge type args`,
            `  z = arg1 + arg4 + 1l`,
            ``,
            `  ; merge type args`,
            `  a2 = arg1 + arg4 + 1`,
            ``,
            `  ; merge type args`,
            `  b2 = arg1 + arg4 + arg5`,
            ``,
            `  ; any`,
            `  c2 = arg1[arg6]`,
            ``,
            `  ; any`,
            `  d2 = arg1 + arg4 + arg6`,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Types from`,
      fileName: `types.indexing.ordered-hashes.spec.ts`,
      tests: [
        {
          name: 'ordered hashes',
          code: [
            `;+`,
            `; :Returns:`,
            `;   Number`,
            `;`,
            `;-`,
            `function myfunc`,
            `  compile_opt idl2`,
            ``,
            `  return, 1`,
            `end`,
            ``,
            `;+`,
            `; :Returns:`,
            `;   Array<Number>`,
            `;`,
            `;-`,
            `function myfunc2`,
            `  compile_opt idl2`,
            ``,
            `  return, 1`,
            `end`,
            ``,
            `;+`,
            `; :Arguments:`,
            `;   arg1: in, required, OrderedHash<Number | String>`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   arg2: in, required, Array<Number>`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   arg3: in, required, Array<any>`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   arg4: in, required, Array<Byte>`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   arg5: in, required, Array<ENVIRaster>`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   arg6: in, required, any`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;`,
            `;-`,
            `pro ordered_hashes, arg1, arg2, arg3, arg4, arg5, arg6`,
            `  compile_opt idl3`,
            ``,
            `  ; type args`,
            `  c = arg1[0]`,
            ``,
            `  ; return array of type args`,
            `  d = arg1[arg2]`,
            ``,
            `  ; return array`,
            `  e = arg1[*]`,
            ``,
            `  ; return array`,
            `  f = arg1[0, 1, *]`,
            ``,
            `  ; return type args`,
            `  g = arg1[myfunc()]`,
            ``,
            `  ; return array`,
            `  h = arg1[myfunc2()]`,
            ``,
            `  ; type args`,
            `  i = arg1[0, 1, 2]`,
            ``,
            `  ; return array`,
            `  j = arg1[0, 1, myfunc2()]`,
            ``,
            `  ; return array`,
            `  k = arg1[0 : -1 : 1]`,
            ``,
            `  ; return array`,
            `  l = arg1[0, 1, *]`,
            ``,
            `  ; return type args`,
            `  m = arg1[-1]`,
            ``,
            `  ; any`,
            `  n = arg3[0]`,
            ``,
            `  ; array of any`,
            `  o = arg3[myfunc2()]`,
            ``,
            `  ; return array`,
            `  p = arg1[0, myfunc2(), 1]`,
            ``,
            `  ; return array`,
            `  q = arg1[[1, 2, 3]]`,
            ``,
            `  ; return type args`,
            `  r = arg1[1 + 2]`,
            ``,
            `  ; return array`,
            `  s = arg1[1 + myfunc2()]`,
            ``,
            `  ; return any`,
            `  t = arg1[plot()]`,
            ``,
            `  ; return any`,
            `  u = arg1[1j]`,
            ``,
            `  ; return any`,
            `  v = arg1[1i]`,
            ``,
            `  ; return any`,
            `  w = arg1[1di]`,
            ``,
            `  ; return any`,
            `  x = arg1[1dj]`,
            ``,
            `  ; merge type args`,
            `  y = arg1 + arg3`,
            ``,
            `  ; merge type args`,
            `  z = arg1 + arg4 + 1l`,
            ``,
            `  ; merge type args`,
            `  a2 = arg1 + arg4 + 1`,
            ``,
            `  ; merge type args`,
            `  b2 = arg1 + arg4 + arg5`,
            ``,
            `  ; any`,
            `  c2 = arg1[arg6]`,
            ``,
            `  ; any`,
            `  d2 = arg1 + arg4 + arg6`,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Types from`,
      fileName: `types.indexing.properties.spec.ts`,
      tests: [
        {
          name: 'property indexing',
          code: [
            `pro mypro1`,
            `  compile_opt idl2`,
            `  ; number or array of numbers`,
            `  index = where('5' eq fn)`,
            `  ; any`,
            `  x = (!null).(1)[index]`,
            `end`,
            ``,
          ],
        },
      ],
    },
    {
      suiteName: `Types from`,
      fileName: `types.indexing.edge-cases.spec.ts`,
      tests: [
        {
          name: 'indexing compound types',
          code: [
            `compile_opt idl2`,
            `; should be number`,
            `rb_match = (where(5 eq [1, 2, 3, 4, 5]))[0]`,
            `end`,
            ``,
          ],
        },
        {
          name: 'scalar with array',
          code: [
            `compile_opt idl2`,
            `polyColors = 5l`,
            `array1 = polyColors[idx : nMax]`,
            `array2 = polyColors[[5 : 15: 1]]`,
            `end`,
            ``,
          ],
        },
      ],
    },
    {
      suiteName: `Types from`,
      fileName: `types.keywords.spec.ts`,
      tests: [
        {
          name: `output or bidirectional keywords`,
          code: [
            `;+`,
            `; :Description:`,
            `;   Constructor`,
            `;`,
            `; :Returns:`,
            `;   myclass`,
            `;`,
            `;-`,
            `function myclass::Init`,
            `  compile_opt idl2`,
            ``,
            `  return, 1`,
            `end`,
            ``,
            `;+`,
            `; :Returns:`,
            `;   any`,
            `;`,
            `; :Keywords:`,
            `;   kw: out, optional, Array<Number>`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;`,
            `;-`,
            `function myclass::method, kw = kw`,
            `  compile_opt idl2`,
            `  return, 1`,
            `end`,
            ``,
            `;+`,
            `; :Keywords:`,
            `;   kw: out, optional, ENVIRaster`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;`,
            `;-`,
            `pro myclass::method, kw = kw`,
            `  compile_opt idl2`,
            `end`,
            ``,
            `;+`,
            `; :Description:`,
            `;   Class definition procedure`,
            `;`,
            `;-`,
            `pro myclass__define`,
            `  compile_opt idl2`,
            ``,
            `  struct = {myclass}`,
            `end`,
            ``,
            `;+`,
            `; :Returns:`,
            `;   any`,
            `;`,
            `; :Keywords:`,
            `;   kw: out, optional, Long`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;`,
            `;-`,
            `function myfunc, kw = kw`,
            `  compile_opt idl2`,
            `  return, 1`,
            `end`,
            ``,
            `;+`,
            `; :Keywords:`,
            `;   kw: out, optional, Byte`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;`,
            `;-`,
            `pro mypro, kw = kw`,
            `  compile_opt idl2`,
            ``,
            `end`,
            ``,
            `; main level program`,
            `compile_opt idl2`,
            ``,
            `; procedures`,
            `mypro, kw = a`,
            ``,
            `; functions`,
            `!null = myfunc(kw = b)`,
            ``,
            `; make class for methods`,
            `var = myclass()`,
            ``,
            `; procedure methods`,
            `var.method, kw = c`,
            ``,
            `; function methods`,
            `!null = var.method(kw = d)`,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Types from`,
      fileName: `types.operations.structures.spec.ts`,
      tests: [
        {
          name: `structure operations`,
          code: [
            `pro struct_checks`,
            `compile_opt idl2`,
            ``,
            `str = {a: 42}`,
            ``,
            `a = 1 + str`,
            ``,
            `b = str + {a: 42}`,
            ``,
            `c = str + list()`,
            ``,
            `d = str + hash()`,
            ``,
            `e = str + orderedhash()`,
            ``,
            `f = str + dictionary()`,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Types from`,
      fileName: `types.operations.list.spec.ts`,
      tests: [
        {
          name: `list operations`,
          code: [
            `pro list_checks`,
            `compile_opt idl2`,
            ``,
            `a = 1 + list()`,
            ``,
            `b = list() + list()`,
            ``,
            `c = list() + hash()`,
            ``,
            `d = list() + orderedhash()`,
            ``,
            `e = list() + dictionary()`,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Types from`,
      fileName: `types.operations.hash.spec.ts`,
      tests: [
        {
          name: `hash operations`,
          code: [
            `pro hash_checks`,
            `compile_opt idl2`,
            ``,
            `a = 1 + hash()`,
            ``,
            `b = hash() + list()`,
            ``,
            `c = hash() + hash()`,
            ``,
            `d = hash() + orderedhash()`,
            ``,
            `e = hash() + dictionary()`,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Types from`,
      fileName: `types.operations.ordered-hash.spec.ts`,
      tests: [
        {
          name: `ordered hash operations`,
          code: [
            `pro orderedhash_checks`,
            `compile_opt idl2`,
            ``,
            `a = 1 + orderedhash()`,
            ``,
            `b = orderedhash() + list()`,
            ``,
            `c = orderedhash() + hash()`,
            ``,
            `d = orderedhash() + orderedhash()`,
            ``,
            `e = orderedhash() + dictionary()`,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Types from`,
      fileName: `types.operations.dictionary.spec.ts`,
      tests: [
        {
          name: `dictionary operations`,
          code: [
            `pro dictionary_checks`,
            `compile_opt idl2`,
            ``,
            `a = 1 + dictionary()`,
            ``,
            `b = dictionary() + list()`,
            ``,
            `c = dictionary() + hash()`,
            ``,
            `d = dictionary() + orderedhash()`,
            ``,
            `e = dictionary() + dictionary()`,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Cases to make sure we always parse our types correctly`,
      fileName: `types.parsing-checks.1.spec.ts`,
      tests: [
        {
          name: 'for normal cases',
          code: [
            `;+`,
            `; :Arguments:`,
            `;   arg1: in, required, Pointer`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   arg2: in, required, Pointer<Array>`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   arg3: in, required, Pointer<Array<Number>>`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   arg4: in, required, Pointer<Array<Number>`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   arg5: in, required, Number | String`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   arg6: in, required, Hash<Number> | List<Array<Number>>`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   arg7: in, required, Hash<Number | string> | List<Array<Number | string> | List<ENVIRaster>>`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;`,
            `;-`,
            `pro type_parsing_test, arg1, arg2, arg3, arg4, arg5, arg6, arg7`,
            `  compile_opt idl3`,
            ``,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Get types correctly from pointer de-reference`,
      fileName: `types.pointer-de-ref.1.spec.ts`,
      tests: [
        {
          name: 'for normal cases',
          code: [
            `;+`,
            `; :Arguments:`,
            `;   arg1: in, required, Pointer<Number>`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   arg2: in, required, Array<Number>`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   arg3: in, required, Array<Pointer<ENVIRaster>>`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   arg4: in, required, Pointer<Number> | String`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   arg5: in, required, Pointer<any>`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   arg6: in, required, Pointer<String> | Pointer<Number>`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   arg7: in, required, Pointer<String> | Pointer<Number | String>`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;`,
            `;-`,
            `pro pointers, arg1, arg2, arg3, arg4, arg5, arg6, arg7`,
            `  compile_opt idl3`,
            ``,
            `  ; number`,
            `  a = *arg1`,
            ``,
            `  ; enviraster`,
            `  b = *arg3[0]`,
            ``,
            `  ; and, unable to index`,
            `  c = arg1[0]`,
            ``,
            `  ; any, unable to de-reference`,
            `  d = *5`,
            ``,
            `  ; any, ambiguous de-reference`,
            `  e = *arg4`,
            ``,
            `  ; any`,
            `  f = *arg5`,
            ``,
            `  ; union of type args`,
            `  g = *arg6`,
            ``,
            `  ; union of type args, dont show arg7 more string more than once`,
            `  g = *arg7`,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Types from`,
      fileName: `types.promotion1.spec.ts`,
      tests: [
        {
          name: 'type promotion',
          code: [
            `;+`,
            `; :Returns:`,
            `;   any`,
            `;`,
            `; :Arguments:`,
            `;   a: in, required, Number`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;   b: in, required, ComplexNumber`,
            `;     Placeholder docs for argument, keyword, or property`,
            `;`,
            `;-`,
            `function most_cases, a, b`,
            `  compile_opt idl2`,
            ``,
            `  byte = 's' + 1b`,
            ``,
            `  int = 's' + 1s`,
            ``,
            `  uint = 's' + 1us`,
            ``,
            `  long = 's' + 1l`,
            ``,
            `  ulong = 's' + 1ul`,
            ``,
            `  long64 = 's' + 1ll`,
            ``,
            `  ulong64 = 's' + 1ull`,
            ``,
            `  float1 = 's' + 1.`,
            `  float2 = 's' + 1e`,
            ``,
            `  double = 's' + 1d`,
            ``,
            `  biginteger = 's' + BigInteger(5)`,
            ``,
            `  number = 's' + a`,
            ``,
            `  complexfloat = 's' + 1.i`,
            ``,
            `  complexdouble = 's' + 1di`,
            `  complexdouble = 's' + 1dj`,
            ``,
            `  complexnumber1 = 's' + a + 1di + 1dj`,
            `  complexnumber2 = a + b`,
            ``,
            `  return, 1`,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Types from`,
      fileName: `types.strings.spec.ts`,
      tests: [
        {
          name: 'strings',
          code: [
            `pro myPro`,
            `  compile_opt idl2`,
            ``,
            `  a = 'single quote'`,
            ``,
            `  b = "double quote"`,
            ``,
            `  c = \`literal string\``,
            ``,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Types from`,
      fileName: `types.ternary.spec.ts`,
      tests: [
        {
          name: 'ternary',
          code: [
            `pro myPro`,
            `  compile_opt idl2`,
            ``,
            `  ; long or envi`,
            `  a = !true ? 5 + 15 : envi()`,
            ``,
            `  ; long or string`,
            `  b = !true ? 5 + 15 : 'string'`,
            ``,
            `  ; string`,
            `  c = !true ? 'string' : 'false'`,
            ``,
            `  ; number`,
            `  d = !true ? 5 : 6`,
            ``,
            `  ; any`,
            `  e = !true ? 5 `,
            ``,
            `  ; any`,
            `  f = !true ? 5 :`,
            ``,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Types from`,
      fileName: `types.variables.spec.ts`,
      tests: [
        {
          name: 'variables',
          code: [
            `pro myPro`,
            `  compile_opt idl2`,
            ``,
            `  a = ENVISubsetRaster()`,
            ``,
            `  b = a`,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Types from`,
      fileName: `types.static-classes.spec.ts`,
      tests: [
        {
          name: 'named static classes methods/properties',
          code: [
            `pro myPro`,
            `  compile_opt idl2`,
            ``,
            `  a = IDL_Number.ndim`,
            `  b = envi.openRaster()`,
            `  any1 = image ; nothing`,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Types from`,
      fileName: `types.structure-names.spec.ts`,
      tests: [
        {
          name: 'named structures',
          code: [
            `pro myPro`,
            `  compile_opt idl2`,
            ``,
            `  a = {ENVIRaster}`,
            ``,
            `  b = {!map}`,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Types from`,
      fileName: `types.structure-anonymous.spec.ts`,
      tests: [
        {
          name: 'anonymous structures',
          code: [
            `pro myPro`,
            `  compile_opt idl2`,
            ``,
            `  a = {a: 'string', $`,
            `    b: \`string\`}`,
            ``,
            `end`,
          ],
        },
      ],
    },
    {
      suiteName: `Types from`,
      fileName: `types.system-variables.spec.ts`,
      tests: [
        {
          name: 'the !null system variable',
          code: [`pro myPro`, `  compile_opt idl2`, ``, `  a = !null`, `end`],
        },
        {
          name: 'system variables that are structures',
          code: [`pro myPro`, `  compile_opt idl2`, ``, `  a = !x`, `end`],
        },
      ],
    },
  ];
