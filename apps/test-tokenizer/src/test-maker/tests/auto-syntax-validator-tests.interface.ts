import { IAutoSyntaxValidatorTest } from '../tests.interface';

/**
 * Automated tests for each problem code that we validate
 */
export const AUTO_SYNTAX_TESTS: IAutoSyntaxValidatorTest[] = [
  {
    suiteName: `Verify that we can parse and report problems`,
    fileName: `bad-routine-def.spec.ts`,
    tests: [
      {
        name: `for bad function`,
        code: [
          `function `,
          ``,
          `; pro test_myurl`,
          ``,
          `a = curl_easy_init()`,
          `curlopt_header = 42`,
          `print, 'curl_easy_setopt', curl_easy_setopt(a, curlopt_header, 1)`,
          `curlopt_url = 10002`,
          `print, 'curl_easy_setopt', curl_easy_setopt(a, curlopt_url, 'http://www.google.com')`,
          `print, 'curl_easy_perform', curl_easy_perform(a)`,
          `curl_easy_cleanup, a`,
          `end`,
        ],
      },
      {
        name: `for bad pro`,
        code: [
          `pro `,
          ``,
          `; pro test_myurl`,
          ``,
          `a = curl_easy_init()`,
          `curlopt_header = 42`,
          `print, 'curl_easy_setopt', curl_easy_setopt(a, curlopt_header, 1)`,
          `curlopt_url = 10002`,
          `print, 'curl_easy_setopt', curl_easy_setopt(a, curlopt_url, 'http://www.google.com')`,
          `print, 'curl_easy_perform', curl_easy_perform(a)`,
          `curl_easy_cleanup, a`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Detects problems with statements not being closed`,
    fileName: `code.0.not-closed.spec.ts`,
    tests: [
      {
        name: `parentheses`,
        code: `(`,
      },
      {
        name: `brackets`,
        code: `[`,
      },
      {
        name: `structures`,
        code: `{`,
      },
      {
        name: `functions`,
        code: `myfunc(`,
      },
      {
        name: `blocks`,
        code: `begin`,
      },
      {
        name: `switch`,
        code: `switch`,
      },
      {
        name: `case`,
        code: `case`,
      },
      {
        name: `procedures`,
        code: `pro mypro`,
      },
      {
        name: `functions`,
        code: `function myfunc`,
      },
      {
        name: `across line boundaries`,
        code: [`( $`, ` ;something`],
      },
      {
        name: `only report last instance of unclosed in main`,
        code: [
          `compile_opt idl2`,
          `p = plot(var var, $`,
          `  plot(var var`,
          `end`,
        ],
      },
      {
        name: `only report last instance of unclosed in routine`,
        code: [
          `pro myAwesomePro`,
          `compile_opt idl2`,
          `p = plot(var var, $`,
          `  plot(var var`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Detects unexpected closers`,
    fileName: `code.1.unexpected-closer.spec.ts`,
    tests: [
      {
        name: `finds all unexpected closers`,
        code: [
          `)`,
          `]`,
          `}`,
          `endif`,
          `endelse`,
          `endfor`,
          `endforeach`,
          `endrep`,
          `endwhile`,
          `endswitch`,
          `endcase`,
          `end`,
        ],
      },
      {
        name: `correctly processes routines and expects no errors`,
        code: [
          `Function f1`,
          `  if keyword_set(fclip) then begin`,
          `    return, 1`,
          `  endif`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Detects problems after main level`,
    fileName: `code.3.after-main.spec.ts`,
    tests: [
      {
        name: `statements after main level`,
        code: [`compile_opt idl2`, `end`, `a = 5`],
      },
      {
        name: `allow comments after main`,
        code: [`compile_opt idl2`, `end`, `; ok`],
      },
    ],
  },
  {
    suiteName: `Detects TODO statements`,
    fileName: `code.6.todo.spec.ts`,
    tests: [
      {
        name: `with basic lower-case comment`,
        code: `; todo: something`,
      },
      {
        name: `with basic upper-case comment`,
        code: `; todo: something`,
      },
    ],
  },
  {
    suiteName: `Detects unknown tokens`,
    fileName: `code.7.unknown-token.spec.ts`,
    tests: [
      {
        name: `with example in structure`,
        code: `a = {1+2}`,
      },
      {
        name: `after line continuation`,
        code: [`compile_opt idl2`, `a = $ , $ ; ok`, `42`, `end`],
      },
      {
        name: `ternary without assignment`,
        code: `!true ? a : b`,
      },
      {
        name: `comma in assignment`,
        code: `a = ,`,
      },
      {
        name: `quotes in structures 1`,
        code: `a = {'bad'}`,
      },
      {
        name: `quotes in structures 2`,
        code: `a = {"bad"}`,
      },
    ],
  },
  {
    suiteName: `Detects illegal arrows`,
    fileName: `code.8.illegal-arrow.spec.ts`,
    tests: [
      {
        name: `missing super/method`,
        code: [`compile_opt idl2`, `a  = b-> $`, `method`, `end`],
      },
      {
        name: `missing method with super before`,
        code: [
          `compile_opt idl2`,
          `oContainer = self->IDLitContainer:: $`,
          `method`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Detects illegal commas`,
    fileName: `code.9.illegal-comma.spec.ts`,
    tests: [
      {
        name: `after assignment`,
        code: `a = ,`,
      },
      {
        name: `standalone`,
        code: `,`,
      },
      {
        name: `in right place`,
        code: [`a = something()`, `,`],
      },
      {
        name: `in parentheses`,
        code: [`a = (,)`],
      },
      {
        name: `in switch`,
        code: [
          `compile_opt idl2`,
          `switch a, of`,
          ` , !true: , `,
          `endswitch`,
          `end`,
        ],
      },
      {
        name: `in case`,
        code: [
          `compile_opt idl2`,
          `case a, of`,
          ` , !true: , `,
          `endcase`,
          `end`,
        ],
      },
      {
        name: `in ternary`,
        code: [`a = !true ? ,'bad' : ,'still bad'`],
      },
    ],
  },
  {
    suiteName: `Detects illegal colon`,
    fileName: `code.10.illegal-colon.spec.ts`,
    tests: [
      {
        name: `standalone`,
        code: `:`,
      },
      {
        name: `with reserved word in jump statement`,
        code: `break:`,
      },
      {
        name: `function call`,
        code: `myfunc(a:b)`,
      },
      {
        name: `bad array syntax`,
        code: `myarr(a:b)`,
      },
      {
        name: `ignore lambda functions`,
        code: `a = lambda(x:x+2)`,
      },
    ],
  },
  {
    suiteName: `Detects illegal include statements`,
    fileName: `code.11.illegal-include.spec.ts`,
    tests: [
      {
        name: `correctly find no problems`,
        code: `@includeme`,
      },
      {
        name: `don't find in functions`,
        code: `a = myfunc(@bad)`,
      },
      {
        name: `don't find in expressions`,
        code: `a = @include_wrong + @way_bad`,
      },
    ],
  },
  {
    suiteName: `Detects reserved variable names. Not all are detected as you might think and require other syntax rules to verify`,
    fileName: `code.12.reserved-var.spec.ts`,
    tests: [
      { name: `correctly detects "for"`, code: `a = for` },
      { name: `correctly detects "foreach"`, code: `a = foreach` },
      { name: `correctly detects "while"`, code: `a = while` },
      { name: `correctly detects "do"`, code: `a = do` },
      { name: `correctly detects "repeat"`, code: `a = repeat` },
      { name: `correctly detects "until"`, code: `a = until` },
      { name: `correctly detects "if"`, code: `a = if` },
      { name: `correctly detects "then"`, code: `a = then` },
      { name: `correctly detects "else"`, code: `a = else` },
      { name: `correctly detects "switch"`, code: `a = switch` },
      { name: `correctly detects "case"`, code: `a = case` },
      { name: `correctly detects "of"`, code: `a = of` },
      { name: `correctly detects "begin"`, code: `a = begin` },
      { name: `correctly detects "end"`, code: `a = end` },
      { name: `correctly detects "endif"`, code: `a = endif` },
      { name: `correctly detects "endelse"`, code: `a = endelse` },
      { name: `correctly detects "endfor"`, code: `a = endfor` },
      { name: `correctly detects "endforeach"`, code: `a = endforeach` },
      { name: `correctly detects "endrep"`, code: `a = endrep` },
      { name: `correctly detects "endwhile"`, code: `a = endwhile` },
      { name: `correctly detects "endswitch"`, code: `a = endswitch` },
      { name: `correctly detects "endcase"`, code: `a = endcase` },
      { name: `correctly detects "pro"`, code: `a = pro` },
      { name: `correctly detects "function"`, code: `a = function` },
      { name: `correctly detects "break"`, code: `a = break` },
      { name: `correctly detects "continue"`, code: `a = continue` },
      { name: `correctly detects "common"`, code: `a = common` },
      { name: `correctly detects "compile_opt"`, code: `a = compile_opt` },
      {
        name: `correctly detects "forward_function"`,
        code: `a = forward_function`,
      },
      { name: `correctly detects "goto"`, code: `a = goto` },
      { name: `correctly detects "mod"`, code: `a = mod` },
      { name: `correctly detects "not"`, code: `a = not` },
      { name: `correctly detects "eq"`, code: `a = eq` },
      { name: `correctly detects "ne"`, code: `a = ne` },
      { name: `correctly detects "le"`, code: `a = le` },
      { name: `correctly detects "lt"`, code: `a = lt` },
      { name: `correctly detects "ge"`, code: `a = ge` },
      { name: `correctly detects "gt"`, code: `a = gt` },
      { name: `correctly detects "and"`, code: `a = and` },
      { name: `correctly detects "or"`, code: `a = or` },
      { name: `correctly detects "xor"`, code: `a = xor` },
      { name: `correctly detects "inherits"`, code: `a = inherits` },
    ],
  },
  {
    suiteName: `Detects illegal ternary operators`,
    fileName: `code.13.illegal-ternary.spec.ts`,
    tests: [
      {
        name: `correctly find no problems`,
        code: `a = !true ? 'yes' : 'no'`,
      },
      {
        name: `find problem`,
        code: `!true ? 'yes' : 'no'`,
      },
    ],
  },
  {
    suiteName: `Detects illegal colons in functions`,
    fileName: `code.14.colon-in-func.spec.ts`,
    tests: [
      {
        name: `find problem`,
        code: `a = var(0:-1)`,
      },
    ],
  },
  {
    suiteName: `Detects illegal colons in function methods`,
    fileName: `code.15.colon-in-func-method.spec.ts`,
    tests: [
      {
        name: `find problem`,
        code: `a = objOrStruct.var(0:-1)`,
      },
    ],
  },
  {
    suiteName: `Detects two tokens next to each other`,
    fileName: `code.16.double-token.spec.ts`,
    tests: [
      {
        name: `variables`,
        code: `procedure, var1 var2`,
      },
      {
        name: `functions`,
        code: `func1() func2()`,
      },
      {
        name: `operators`,
        code: `a + + b`,
      },
      {
        name: `commas`,
        code: `mypro,,`,
      },
      {
        name: `valid structures`,
        code: `a = {mystruct, {known:val}}`,
      },
      {
        name: `bad structures`,
        code: `a = {{known:val}}`,
      },
      {
        name: `ignore comments`,
        code: [`; first`, `;second`],
      },
      {
        name: `OK separate lines`,
        code: [`pro1`, `pro2`],
      },
      {
        name: `All of these operators can be next to each other`,
        code: [
          `compile_opt idl2`,
          `a = b && ~c && d`,
          `a = b || ~c || d`,
          `a = b not ~c not d`,
          `a = b eq ~c eq d`,
          `a = b ne ~c ne d`,
          `a = b le ~c le d`,
          `a = b lt ~c lt d`,
          `a = b ge ~c gt d`,
          `a = b gt ~c gt d`,
          `a = b and ~c and d`,
          `a = b or ~c or d`,
          `a = b xor ~c xor d`,
          `a = b.prop.prop.prop`,
          `a = 42 & b = 42 & c = 42`,
          `tol = (N_ELEMENTS(tolIn) eq 1) ? tolIn[0] : use_double ? 2d-12 : 1e-5`,
          `end`,
        ],
      },
      {
        name: `ignore template escape characters`,
        code: [`a = \`\\r\\r\\n\\n\``],
      },
      {
        name: `ignore nested function methods (caught elsewhere)`,
        code: [`a = var.myfunc().ohNotOk()`],
      },
    ],
  },
  {
    suiteName: `Allows these tokens next to each other`,
    fileName: `code.16.double-token.exclusions1.spec.ts`,
    tests: [
      {
        name: `string literal expressions`,
        code: `a = \`\${42}\${42}\``,
      },
    ],
  },
  {
    suiteName: `Detects illegal colons in function methods`,
    fileName: `code.17.illegal-struct.spec.ts`,
    tests: [
      {
        name: `find problem`,
        code: `a ={{}}`,
      },
    ],
  },
  {
    suiteName: `Detects illegal colons in function methods`,
    fileName: `code.18.illegal-paren.spec.ts`,
    tests: [
      {
        name: `find problem`,
        code: `a = {()}`,
      },
    ],
  },
  {
    suiteName: `Detects illegal colons in function methods`,
    fileName: `code.19.illegal-bracket.spec.ts`,
    tests: [
      {
        name: `find problem`,
        code: `a = {[]}`,
      },
    ],
  },
  {
    suiteName: `Detects invalid return statements in procedures`,
    fileName: `code.20.return-vals-pro.spec.ts`,
    tests: [
      {
        name: `ok in procedure`,
        code: [`pro mypro`, `  compile_opt idl2`, `  return`, `end`],
      },
      {
        name: `ok in main`,
        code: [`  compile_opt idl2`, `  return`, `end`],
      },
      {
        name: `bad`,
        code: [`pro mypro`, `  compile_opt idl2`, `  return,`, `end`],
      },
      {
        name: `bad in objects`,
        code: [`pro mypro::method`, `  compile_opt idl2`, `  return,`, `end`],
      },
      {
        name: `bad in main`,
        code: [`  compile_opt idl2`, `  return,`, `end`],
      },
      {
        name: `ok with comment after return`,
        code: [`pro mypro`, `  compile_opt idl2`, `  return ; done`, `end`],
      },
    ],
  },
  {
    suiteName: `Detects invalid return statements in functions (too many vals)`,
    fileName: `code.21.return-vals-func.spec.ts`,
    tests: [
      {
        name: `ok`,
        code: [`function myfunc`, `  compile_opt idl2`, `  return,1`, `end`],
      },
      {
        name: `bad`,
        code: [`function myfunc`, `  compile_opt idl2`, `  return,1,2`, `end`],
      },
      {
        name: `bad in objects`,
        code: [
          `function myfunc::method`,
          `  compile_opt idl2`,
          `  return,1,2`,
          `end`,
        ],
      },
      {
        name: `return value from function OK`,
        code: [
          `function myfunc`,
          `  compile_opt idl2`,
          `  return,weirdCall(1,2,3)`,
          `end`,
        ],
      },
      {
        name: `ok with comment after return`,
        code: [
          `function mypro`,
          `  compile_opt idl2`,
          `  return, 1 ; done`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Detects invalid return statements in functions (no val)`,
    fileName: `code.22.return-vals-missing-func.spec.ts`,
    tests: [
      {
        name: `ok`,
        code: [`function myfunc`, `  compile_opt idl2`, `  return,1`, `end`],
      },
      {
        name: `bad`,
        code: [`function myfunc`, `  compile_opt idl2`, `  return`, `end`],
      },
      {
        name: `bad in objects`,
        code: [
          `function myfunc::method`,
          `  compile_opt idl2`,
          `  return`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Detects reserved procedures`,
    fileName: `code.29.reserved-pro.spec.ts`,
    tests: [
      {
        name: `ok procedure`,
        code: [`pro mypro`, `  compile_opt idl2`, `  return`, `end`],
      },
      {
        name: `bad procedure`,
        code: [`pro WRITEU`, `  compile_opt idl2`, ``, `end`],
      },
    ],
  },
  {
    suiteName: `Detects reserved functions`,
    fileName: `code.30.reserved-func.spec.ts`,
    tests: [
      {
        name: `ok function`,
        code: [`function myfunc`, `  compile_opt idl2`, `  return,1`, `end`],
      },
      {
        name: `bad function`,
        code: [
          `function label_region`,
          `  compile_opt idl2`,
          `  return,1`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Detects missing return procedure in functions`,
    fileName: `code.31.return-missing.spec.ts`,
    tests: [
      {
        name: `ok function`,
        code: [`function myfunc`, `  compile_opt idl2`, `  return,1`, `end`],
      },
      {
        name: `bad function`,
        code: [`function myfunc`, `  compile_opt idl2`, ``, `end`],
      },
      {
        name: `ok in methods`,
        code: [
          `function myfunc::method`,
          `  compile_opt idl2`,
          `  return,1`,
          `end`,
        ],
      },
      {
        name: `bad in methods`,
        code: [`function myfunc::method`, `  compile_opt idl2`, ``, `end`],
      },
    ],
  },
  {
    suiteName: `Detects invalid tokens before routine definition`,
    fileName: `code.32.routines-first.spec.ts`,
    tests: [
      {
        name: `no problems`,
        code: [
          `@include`,
          ``,
          `function myfunc`,
          `  compile_opt idl2`,
          `  return,1`,
          `end`,
          ``,
          `compile_opt idl2`,
          `; main level`,
          `something = 42`,
          `end`,
        ],
      },
      {
        name: `all the problems`,
        code: [
          `; this is OK`,
          `this = wrong * 5`,
          ``,
          `; this is OK too`,
          `function myfunc`,
          `  compile_opt idl2`,
          `  return,1`,
          `end`,
          ``,
          `; main level`,
          `something = 42`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Detects missing end to main level program`,
    fileName: `code.33.unclosed-main.spec.ts`,
    tests: [
      {
        name: `no problems`,
        code: [
          `function myfunc`,
          `  compile_opt idl2`,
          `  return,1`,
          `end`,
          ``,
          `compile_opt idl2`,
          `; main level`,
          `something = 42`,
          `end`,
        ],
      },
      {
        name: `all the problems`,
        code: [
          `function myfunc`,
          `  compile_opt idl2`,
          `  return,1`,
          `end`,
          ``,
          `compile_opt idl2`,
          `; main level`,
          `something = 42`,
        ],
      },
      {
        name: `problems after end`,
        code: [
          `function myfunc`,
          `  compile_opt idl2`,
          `  return,1`,
          `end`,
          ``,
          `compile_opt idl2`,
          `; main level`,
          `something = 42`,
          `end`,
          `a = 17`,
        ],
      },
      {
        name: `not problem`,
        code: [
          `function myfunc`,
          `  compile_opt idl2`,
          `  return,1`,
          `end ; -----------`,
          ``,
          `; main level`,
          `; another comment`,
        ],
      },
    ],
  },
  {
    suiteName: `Detects missing end to main level program`,
    fileName: `code.33.unclosed-main.notebooks.spec.ts`,
    tests: [
      {
        name: `no problems`,
        code: [
          `function myfunc`,
          `  compile_opt idl2`,
          `  return,1`,
          `end`,
          ``,
          `compile_opt idl2`,
          `; main level`,
          `something = 42`,
          `end`,
        ],
        config: {
          isNotebook: true,
        },
      },
      {
        name: `no problems`,
        code: [
          `function myfunc`,
          `  compile_opt idl2`,
          `  return,1`,
          `end`,
          ``,
          `compile_opt idl2`,
          `; main level`,
          `something = 42`,
        ],
        config: {
          isNotebook: true,
        },
      },
      {
        name: `no problems`,
        code: [
          `function myfunc`,
          `  compile_opt idl2`,
          `  return,1`,
          `end`,
          ``,
          `a = myfunc()`,
        ],
        config: {
          isNotebook: true,
        },
      },
    ],
  },
  {
    suiteName: `Detects empty main level programs`,
    fileName: `code.34.empty-main.spec.ts`,
    tests: [
      {
        name: `no problems`,
        code: [`; main level`, `compile_opt idl2`, `something = 42`, `end`],
      },
      {
        name: `all the problems`,
        code: [`; main level`, `end`],
      },
      {
        name: `also problems`,
        code: [``, `end`],
      },
      {
        name: `not problem`,
        code: [
          `function myfunc`,
          `  compile_opt idl2`,
          `  return,1`,
          `end ; -----------`,
          ``,
          `; main level`,
          `; another comment`,
        ],
      },
    ],
  },
  {
    suiteName: `Detects invalid text after line continuations`,
    fileName: `code.35.after-continuation.spec.ts`,
    tests: [
      {
        name: `no problems with nothing after continuation`,
        code: [`compile_opt idl2`, `something = $`, `  5`, `end`],
      },
      {
        name: `no problems with comment`,
        code: [`compile_opt idl2`, `something = $ ; ok`, `  5`, `end`],
      },
      {
        name: `problems`,
        code: [`compile_opt idl2`, `something = $ bad`, `  5`, `end`],
      },
      {
        name: `problems, same location as previous test`,
        code: [`compile_opt idl2`, `something = $ bad ; ok`, `  5`, `end`],
      },
    ],
  },
  {
    suiteName: `Detects reserved procedure methods`,
    fileName: `code.36.reserved-pro-method.spec.ts`,
    tests: [
      {
        name: `ok procedure method`,
        code: [
          `pro IDLffVideoRead::myownmethod`,
          `  compile_opt idl2`,
          `  return`,
          `end`,
        ],
      },
      {
        name: `bad procedure method`,
        code: [`pro IDLffVideoRead::Cleanup`, `  compile_opt idl2`, ``, `end`],
      },
    ],
  },
  {
    suiteName: `Detects reserved function methods`,
    fileName: `code.37.reserved-func-method.spec.ts`,
    tests: [
      {
        name: `ok function method`,
        code: [
          `function list::myownmethod`,
          `  compile_opt idl2`,
          `  return,1`,
          `end`,
        ],
      },
      {
        name: `bad function method`,
        code: [
          `function list::where`,
          `  compile_opt idl2`,
          `  return,1`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Detects missing compile options`,
    fileName: `code.38.no-comp-opt.spec.ts`,
    tests: [
      {
        name: `ok function`,
        code: [`function myfunc`, `  compile_opt idl2`, `  return,1`, `end`],
      },
      {
        name: `bad function`,
        code: [`function myfunc`, `  return,1`, `end`],
      },
      {
        name: `ok procedure`,
        code: [`pro mypro`, `  compile_opt idl2`, `  return`, `end`],
      },
      {
        name: `bad procedure`,
        code: [`pro mypro`, `  return`, `end`],
      },
      {
        name: `ok main`,
        code: [`compile_opt idl2`, `; main level program`, `  a = 5`, `end`],
      },
      {
        name: `bad main`,
        code: [`; main level program`, `  a = 5`, `end`],
      },
      {
        name: `ok main`,
        code: [
          `function myfunc`,
          `  compile_opt idl2`,
          `  return,1`,
          `end ; -----------`,
          ``,
          `; main level`,
          `; another comment`,
        ],
      },
    ],
  },
  {
    suiteName: `Detects missing compile options`,
    fileName: `code.38.no-comp-opt.notebooks.spec.ts`,
    tests: [
      {
        name: `ok function`,
        code: [`function myfunc`, `  compile_opt idl2`, `  return,1`, `end`],
        config: {
          isNotebook: true,
        },
      },
      {
        name: `bad function`,
        code: [`function myfunc`, `  return,1`, `end`],
        config: {
          isNotebook: true,
        },
      },
      {
        name: `ok procedure`,
        code: [`pro mypro`, `  compile_opt idl2`, `  return`, `end`],
        config: {
          isNotebook: true,
        },
      },
      {
        name: `bad procedure`,
        code: [`pro mypro`, `  return`, `end`],
        config: {
          isNotebook: true,
        },
      },
      {
        name: `ok main`,
        code: [`compile_opt idl2`, `; main level program`, `  a = 5`, `end`],
        config: {
          isNotebook: true,
        },
      },
      {
        name: `bad main`,
        code: [`; main level program`, `  a = 5`, `end`],
        config: {
          isNotebook: true,
        },
      },
    ],
  },
  {
    suiteName: `Detects missing compile option idl2`,
    fileName: `code.39.no-idl2.spec.ts`,
    tests: [
      {
        name: `bad function`,
        code: [`function myfunc`, `  compile_opt hidden`, `  return,1`, `end`],
      },
      {
        name: `bad procedure`,
        code: [`pro mypro`, `  compile_opt hidden`, `  return`, `end`],
      },
      {
        name: `don't complain about idl3`,
        code: [`pro mypro`, `  compile_opt idl3`, `  return`, `end`],
      },
    ],
  },
  {
    suiteName: `Detects bad compile options`,
    fileName: `code.40.illegal-comp-opt.spec.ts`,
    tests: [
      {
        name: `bad function`,
        code: [
          `function myfunc`,
          `  compile_opt idl2, bad1`,
          `  return,1`,
          `end`,
        ],
      },
      {
        name: `bad procedure`,
        code: [`pro mypro`, `  compile_opt idl2, bad2`, `  return`, `end`],
      },
    ],
  },
  {
    suiteName: `Detects bad compile options (regression)`,
    fileName: `code.40.illegal-comp-opt.regressions.spec.ts`,
    tests: [
      {
        name: `fine`,
        code: [
          `pro mypro`,
          `  compile_opt idl2, strictarrsubs`,
          `  return`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Detects compile opt without options`,
    fileName: `code.41.empty-comp-opt.spec.ts`,
    tests: [
      {
        name: `bad function`,
        code: [`function myfunc`, `  compile_opt`, `  return,1`, `end`],
      },
      {
        name: `bad procedure`,
        code: [`pro mypro`, `  compile_opt`, `  return`, `end`],
      },
    ],
  },
  {
    suiteName: `Detects compile opt without options`,
    fileName: `code.42.use-idl2.spec.ts`,
    tests: [
      {
        name: `bad function`,
        code: [
          `function myfunc`,
          `  compile_opt defint32, strictarr`,
          `  return,1`,
          `end`,
        ],
      },
      {
        name: `bad procedure`,
        code: [
          `pro mypro`,
          `  compile_opt defint32, strictarr`,
          `  return`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Detects statements that do expect a comma first`,
    fileName: `code.43.expected-comma.spec.ts`,
    tests: [
      {
        name: `in go to`,
        code: [`pro mypro`, `  compile_opt idl2`, `  goto jumper`, `end`],
      },
      {
        name: `in procedure method call`,
        code: [
          `pro mypro`,
          `  compile_opt idl2`,
          `  p = plot(/TEST)`,
          `  p.method abc`,
          `end`,
        ],
      },
      {
        name: `in procedure call`,
        code: [`pro mypro`, `  compile_opt idl2`, `  print something`, `end`],
      },
      {
        name: `in routine name`,
        code: [`pro mypro var1`, `  compile_opt idl2`, `end`],
      },
    ],
  },
  {
    suiteName: `Detects statements that don't expect a comma first`,
    fileName: `code.44.unexpected-comma.spec.ts`,
    tests: [
      {
        name: `verify braces are caught`,
        code: [`pro mypro`, `  compile_opt idl2`, `  a = b[,]`, `end`],
      },
      {
        name: `verify compile_opt is caught`,
        code: [`pro mypro`, `  compile_opt, idl2`, `end`],
      },
      {
        name: `verify common blocks are caught`,
        code: [`pro mypro`, `  compile_opt idl2`, `  common, named`, `end`],
      },
      {
        name: `verify forward function is caught`,
        code: [
          `pro mypro`,
          `  compile_opt idl2`,
          `  forward_function, funcy`,
          `end`,
        ],
      },
      {
        name: `verify function calls are caught`,
        code: [`pro mypro`, `  compile_opt idl2`, `  a = func(,)`, `end`],
      },
      {
        name: `verify function method calls are caught`,
        code: [`pro mypro`, `  compile_opt idl2`, `  a = b.func(,)`, `end`],
      },
      {
        name: `verify for loops are caught`,
        code: [
          `pro mypro`,
          `  compile_opt idl2`,
          `  for, i=0,100 do print, i`,
          `end`,
        ],
      },
      {
        name: `verify foreach loops are caught`,
        code: [
          `pro mypro`,
          `  compile_opt idl2`,
          `  foreach, val, arr do print, val`,
          `end`,
        ],
      },
      {
        name: `verify structures are caught`,
        code: [`pro mypro`, `  compile_opt idl2`, `  a = {,name}`, `end`],
      },
    ],
  },
  {
    suiteName: `Detects multiple compile_opt statements`,
    fileName: `code.45.multiple-comp-opt.spec.ts`,
    tests: [
      {
        name: `bad function`,
        code: [
          `function myfunc`,
          `  compile_opt idl2`,
          `  compile_opt idl2`,
          `  return,1`,
          `end`,
        ],
      },
      {
        name: `bad procedure`,
        code: [
          `pro mypro`,
          `  compile_opt idl2`,
          `  compile_opt idl2`,
          `  return`,
          `end`,
        ],
      },
      {
        name: `bad main`,
        code: [`  compile_opt idl2`, `  compile_opt idl2`, `end`],
      },
    ],
  },
  {
    suiteName: `Detects unclosed quotes`,
    fileName: `code.46.unclosed-quote.spec.ts`,
    tests: [
      {
        name: `ok double quote`,
        code: [`a = "good"`],
      },
      {
        name: `bad double quote`,
        code: [`a = "bad`],
      },
      {
        name: `verify exclude fancy numbers`,
        code: [`a = "0`],
      },
      {
        name: `ok single quote`,
        code: [`a = 'good'`],
      },
      {
        name: `bad single quote`,
        code: [`a = 'bad`],
      },
    ],
  },
  {
    suiteName: `Detects bad argument definitions`,
    fileName: `code.47.args-first.spec.ts`,
    tests: [
      {
        name: `ok args in routine`,
        code: [
          `pro mypro, arg1, arg2, arg3, $`,
          `  arg4, arg5`,
          `  compile_opt idl2`,
          ``,
          `end`,
        ],
      },
      {
        name: `bad args in routine`,
        code: [
          `pro mypro, arg1, arg2, arg3, $`,
          `  arg4, arg5, KW1 = kw1, $`,
          `  arg6, arg7`,
          `  compile_opt idl2`,
          ``,
          `end`,
        ],
      },
      {
        name: `ok args in routine method`,
        code: [
          `pro myclass::mymethod, arg1, arg2, arg3, $`,
          `  arg4, arg5`,
          `  compile_opt idl2`,
          ``,
          `end`,
        ],
      },
      {
        name: `bad args in routine method`,
        code: [
          `pro myclass::mymethod, arg1, arg2, arg3, $`,
          `  arg4, arg5, KW1 = kw1, $`,
          `  arg6, arg7`,
          `  compile_opt idl2`,
          ``,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Detects args missing from docs`,
    fileName: `code.48.docs-missing-arg.spec.ts`,
    tests: [
      {
        name: `no problems`,
        code: [
          `;+`,
          `;`,
          `; :Params:`,
          `;   var1: in, optional, type=boolean`,
          `;     My favorite argument`,
          `;`,
          `;-`,
          `pro myclass::mymethod, var1`,
          `  compile_opt idl2`,
          `end`,
        ],
      },
      {
        name: `problem`,
        code: [
          `;+`,
          `;`,
          `;-`,
          `pro myclass::mymethod, var1`,
          `  compile_opt idl2`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Detects args missing from docs`,
    fileName: `code.48.docs-missing-arg.idldoc-legacy.spec.ts`,
    tests: [
      {
        name: `no problems`,
        code: [
          `;+`,
          `; @description`,
          `;   My favorite routine`,
          `;`,
          `; @param var1 My favorite argument`,
          `;`,
          `;-`,
          `pro myclass::mymethod, var1`,
          `  compile_opt idl2`,
          `end`,
        ],
      },
      {
        name: `problem`,
        code: [
          `;+`,
          `; @description`,
          `;   My favorite routine`,
          `;`,
          `;-`,
          `pro myclass::mymethod, var1`,
          `  compile_opt idl2`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Detects documented args when there are no args`,
    fileName: `code.49.no-args-to-doc.spec.ts`,
    tests: [
      {
        name: `no problems`,
        code: [
          `;+`,
          `;`,
          `; :Params:`,
          `;   var1: in, optional, type=boolean`,
          `;     My favorite argument`,
          `;`,
          `;-`,
          `pro myclass::mymethod, var1`,
          `  compile_opt idl2`,
          `end`,
        ],
      },
      {
        name: `problem`,
        code: [
          `;+`,
          `;`,
          `; :Params:`,
          `;   var1: in, optional, type=boolean`,
          `;     My favorite argument`,
          `;`,
          `;-`,
          `pro myclass::mymethod`,
          `  compile_opt idl2`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Detects documented args when there are no args`,
    fileName: `code.49.no-args-to-doc.idldoc-legacy.spec.ts`,
    tests: [
      {
        name: `no problems`,
        code: [
          `;+`,
          `; @description`,
          `;   My favorite routine`,
          `;`,
          `; @param var1 My favorite argument`,
          `;`,
          `;-`,
          `pro myclass::mymethod, var1`,
          `  compile_opt idl2`,
          `end`,
        ],
      },
      {
        name: `problem`,
        code: [
          `;+`,
          `; @description`,
          `;   My favorite routine`,
          `;`,
          `; @param var1 My favorite argument`,
          `;`,
          `;-`,
          `pro myclass::mymethod`,
          `  compile_opt idl2`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Detects keywords missing from docs`,
    fileName: `code.50.docs-missing-kw.spec.ts`,
    tests: [
      {
        name: `no problems`,
        code: [
          `;+`,
          `;`,
          `; :Keywords:`,
          `;   KW1: in, optional, type=boolean`,
          `;     My favorite argument`,
          `;`,
          `;-`,
          `pro myclass::mymethod, KW1=kw1`,
          `  compile_opt idl2`,
          `end`,
        ],
      },
      {
        name: `problem`,
        code: [
          `;+`,
          `;`,
          `;-`,
          `pro myclass::mymethod, KW1=kw1`,
          `  compile_opt idl2`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Detects keywords missing from docs`,
    fileName: `code.50.docs-missing-kw.idldoc-legacy.spec.ts`,
    tests: [
      {
        name: `no problems`,
        code: [
          `;+`,
          `; @description`,
          `;   My favorite thing`,
          `;`,
          `; @keyword kw1 My favorite keyword`,
          `;`,
          `;-`,
          `pro myclass::mymethod, KW1=kw1`,
          `  compile_opt idl2`,
          `end`,
        ],
      },
      {
        name: `problem`,
        code: [
          `;+`,
          `; @description`,
          `;   My favorite thing`,
          `;`,
          `;-`,
          `pro myclass::mymethod, KW1=kw1`,
          `  compile_opt idl2`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Detects documented keywords when there are no keywords`,
    fileName: `code.51.no-kws-to-doc.spec.ts`,
    tests: [
      {
        name: `no problems`,
        code: [
          `;+`,
          `;`,
          `; :Keywords:`,
          `;   KW1: in, optional, type=boolean`,
          `;     My favorite argument`,
          `;`,
          `;-`,
          `pro myclass::mymethod, KW1=kw1`,
          `  compile_opt idl2`,
          `end`,
        ],
      },
      {
        name: `problem`,
        code: [
          `;+`,
          `;`,
          `; :Keywords:`,
          `;   KW1: in, optional, type=boolean`,
          `;     My favorite argument`,
          `;`,
          `;-`,
          `pro myclass::mymethod`,
          `  compile_opt idl2`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Detects documented keywords when there are no keywords`,
    fileName: `code.51.no-kws-to-doc.idldoc-legacy.spec.ts`,
    tests: [
      {
        name: `no problems`,
        code: [
          `;+`,
          `; @description`,
          `;   My favorite thing`,
          `;`,
          `; @keyword kw1 My favorite keyword`,
          `;`,
          `;-`,
          `pro myclass::mymethod, KW1=kw1`,
          `  compile_opt idl2`,
          `end`,
        ],
      },
      {
        name: `problem`,
        code: [
          `;+`,
          `; @description`,
          `;   My favorite thing`,
          `;`,
          `; @keyword kw1 My favorite keyword`,
          `;`,
          `;-`,
          `pro myclass::mymethod`,
          `  compile_opt idl2`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Detects when the docs are missing return`,
    fileName: `code.52.docs-missing-return.spec.ts`,
    tests: [
      {
        name: `no problems`,
        code: [
          `;+`,
          `; :Returns: number`,
          `;-`,
          `function myfunc`,
          `  compile_opt idl2`,
          `  return, 1`,
          `end`,
        ],
      },
      {
        name: `problem`,
        code: [
          `;+`,
          `;-`,
          `function myfunc`,
          `  compile_opt idl2`,
          `  return, 1`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Detects when the docs are missing return`,
    fileName: `code.52.docs-missing-return.idldoc-legacy.spec.ts`,
    tests: [
      {
        name: `no problems`,
        code: [
          `;+`,
          `; @description`,
          `;   Thing`,
          `;`,
          `; @returns number`,
          `;-`,
          `function myfunc`,
          `  compile_opt idl2`,
          `  return, 1`,
          `end`,
        ],
      },
      {
        name: `problem`,
        code: [
          `;+`,
          `; @description`,
          `;   Thing`,
          `;-`,
          `function myfunc`,
          `  compile_opt idl2`,
          `  return, 1`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Detects when in/out is incorrect for docs`,
    fileName: `code.53.docs-invalid-in-out.spec.ts`,
    tests: [
      {
        name: `no problems`,
        code: [
          `;+`,
          `; :Params:`,
          `;   var1: in, optional, type=boolean`,
          `;     My favorite argument`,
          `;-`,
          `pro myclass::mymethod, var1`,
          `  compile_opt idl2`,
          `end`,
        ],
      },
      {
        name: `problem`,
        code: [
          `;+`,
          `; :Params:`,
          `;   var1: wrong, optional, type=boolean`,
          `;     My favorite argument`,
          `;-`,
          `pro myclass::mymethod, var1`,
          `  compile_opt idl2`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Detects when required/optional is incorrect for docs`,
    fileName: `code.54.docs-invalid-require.spec.ts`,
    tests: [
      {
        name: `no problems`,
        code: [
          `;+`,
          `; :Params:`,
          `;   var1: in, optional, boolean`,
          `;     My favorite argument`,
          `;-`,
          `pro myclass::mymethod, var1`,
          `  compile_opt idl2`,
          `end`,
        ],
      },
      {
        name: `problem`,
        code: [
          `;+`,
          `; :Params:`,
          `;   var1: in, WRONG, boolean`,
          `;     My favorite argument`,
          `;-`,
          `pro myclass::mymethod, var1`,
          `  compile_opt idl2`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Detects when private/public is incorrect for docs`,
    fileName: `code.56.docs-invalid-private.spec.ts`,
    tests: [
      {
        name: `no problems`,
        code: [
          `;+`,
          `; :Params:`,
          `;   var1: in, optional, boolean, public`,
          `;     My favorite argument`,
          `;-`,
          `pro myclass::mymethod, var1`,
          `  compile_opt idl2`,
          `end`,
        ],
      },
      {
        name: `problem`,
        code: [
          `;+`,
          `; :Params:`,
          `;   var1: in, optional, boolean, hidden`,
          `;     My favorite argument`,
          `;-`,
          `pro myclass::mymethod, var1`,
          `  compile_opt idl2`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Detects when not enough documentation parameters are present`,
    fileName: `code.57.docs-too-few-params.spec.ts`,
    tests: [
      {
        name: `no problems for args`,
        code: [
          `;+`,
          `; :Params:`,
          `;   var1: in, optional, boolean`,
          `;     My favorite argument`,
          `;-`,
          `pro myclass::mymethod, var1`,
          `  compile_opt idl2`,
          `end`,
        ],
      },
      {
        name: `problem for args`,
        code: [
          `;+`,
          `; :Params:`,
          `;   var1: in, optional`,
          `;     My favorite argument`,
          `;-`,
          `pro myclass::mymethod, var1`,
          `  compile_opt idl2`,
          `end`,
        ],
      },
      {
        name: `no problems for keywords`,
        code: [
          `;+`,
          `; :Keywords:`,
          `;   var1: in, optional, boolean`,
          `;     My favorite argument`,
          `;-`,
          `pro myclass::mymethod, VAR1=var1`,
          `  compile_opt idl2`,
          `end`,
        ],
      },
      {
        name: `problem for keywords`,
        code: [
          `;+`,
          `; :Keywords:`,
          `;   var1: in, boolean`,
          `;     My favorite argument`,
          `;-`,
          `pro myclass::mymethod, VAR1=var1`,
          `  compile_opt idl2`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Detects when too many documentation parameters are present`,
    fileName: `code.58.docs-too-many-params.spec.ts`,
    tests: [
      {
        name: `no problems for args`,
        code: [
          `;+`,
          `; :Params:`,
          `;   var1: in, optional, boolean`,
          `;     My favorite argument`,
          `;-`,
          `pro myclass::mymethod, var1`,
          `  compile_opt idl2`,
          `end`,
        ],
      },
      {
        name: `problem for args`,
        code: [
          `;+`,
          `; :Params:`,
          `;   var1: in, optional, boolean, private, mcScrooge`,
          `;     My favorite argument`,
          `;-`,
          `pro myclass::mymethod, var1`,
          `  compile_opt idl2`,
          `end`,
        ],
      },
      {
        name: `no problems for keywords`,
        code: [
          `;+`,
          `; :Keywords:`,
          `;   var1: in, optional, boolean`,
          `;     My favorite argument`,
          `;-`,
          `pro myclass::mymethod, VAR1=var1`,
          `  compile_opt idl2`,
          `end`,
        ],
      },
      {
        name: `problem for keywords`,
        code: [
          `;+`,
          `; :Keywords:`,
          `;   var1: in, optional, boolean, public, somethingWrong`,
          `;     My favorite argument`,
          `;-`,
          `pro myclass::mymethod, VAR1=var1`,
          `  compile_opt idl2`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Detects when docs are not left-aligned as expected`,
    fileName: `code.59.docs-left-align.spec.ts`,
    tests: [
      {
        name: `no problems in params/keywords`,
        code: [
          `;+`,
          `; :Params:`,
          `;   var1: in, optional, boolean`,
          `;     My favorite argument`,
          `;     And another line`,
          `;-`,
          `pro myclass::mymethod, var1`,
          `  compile_opt idl2`,
          `end`,
        ],
      },
      {
        name: `problems in params/keywords`,
        code: [
          `;+`,
          `; :Params:`,
          `;   var1: in, optional, boolean`,
          `;     My favorite argument`,
          `;    And another line`,
          `;-`,
          `pro myclass::mymethod, var1`,
          `  compile_opt idl2`,
          `end`,
        ],
      },
      {
        name: `problems in other blocks`,
        code: [
          `;+`,
          `;    First line is great`,
          `;   THEN CHAOS ENSUES`,
          `;`,
          `; :Params:`,
          `;   var1: in, optional, boolean`,
          `;     My favorite argument`,
          `;-`,
          `pro myclass::mymethod, var1`,
          `  compile_opt idl2`,
          `end`,
        ],
      },
      {
        name: `no problems in variables`,
        code: [
          `pro myclass::mymethod, var1`,
          `  compile_opt idl2`,
          `  ;+`,
          `  ; Some things are really awesome`,
          `  ; and need a big description`,
          `  ;-`,
          `  a = 42`,
          `end`,
        ],
      },
      {
        name: `problems in variables`,
        code: [
          `pro myclass::mymethod, var1`,
          `  compile_opt idl2`,
          `  ;+`,
          `  ; Some things are really awesome`,
          `  ;and need a big description`,
          `  ;-`,
          `  a = 42`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Detects when the returns tag for docs is missing the data type`,
    fileName: `code.60.docs-return-has-no-type.spec.ts`,
    tests: [
      {
        name: `no problems`,
        code: [
          `;+`,
          `; :Params:`,
          `;   var1: in, optional, boolean, public`,
          `;     My favorite argument`,
          `; :Returns: number`,
          `;-`,
          `function myfunc, var1`,
          `  compile_opt idl2`,
          `  return, 1`,
          `end`,
        ],
      },
      {
        name: `problem`,
        code: [
          `;+`,
          `; :Params:`,
          `;   var1: in, optional, boolean, public`,
          `;     My favorite argument`,
          `; :Returns:`,
          `;-`,
          `function myfunc, var1`,
          `  compile_opt idl2`,
          `  return, 1`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Detects when the returns tag for docs is missing the data type`,
    fileName: `code.60.docs-return-has-no-type.idldoc-legacy.spec.ts`,
    tests: [
      {
        name: `no problems`,
        code: [
          `;+`,
          `; @param var1 My favorite argument`,
          `;`,
          `; @returns number`,
          `;-`,
          `function myfunc, var1`,
          `  compile_opt idl2`,
          `  return, 1`,
          `end`,
        ],
      },
      {
        name: `problem`,
        code: [
          `;+`,
          `; @param var1 My favorite argument`,
          `;`,
          `; @returns`,
          `;-`,
          `function myfunc, var1`,
          `  compile_opt idl2`,
          `  return, 1`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Detects when the returns tag has too much information (NOT HANDLED FOR LEGACY, regression test)`,
    fileName: `code.61.docs-return-invalid.spec.ts`,
    tests: [
      {
        name: `no problems`,
        code: [
          `;+`,
          `; :Params:`,
          `;   var1: in, optional, boolean, public`,
          `;     My favorite argument`,
          `; :Returns: number`,
          `;-`,
          `function myfunc, var1`,
          `  compile_opt idl2`,
          `  return, 1`,
          `end`,
        ],
      },
      {
        name: `problem`,
        code: [
          `;+`,
          `; :Params:`,
          `;   var1: in, optional, boolean, public`,
          `;     My favorite argument`,
          `; :Returns: number`,
          `;   Fun fact about zach`,
          `;   he is a vegetarian`,
          `;-`,
          `function myfunc, var1`,
          `  compile_opt idl2`,
          `  return, 1`,
          `end`,
        ],
      },
      {
        name: `no problem with extra spaces`,
        code: [
          `;+`,
          `; :Params:`,
          `;   var1: in, optional, boolean, public`,
          `;     My favorite argument`,
          `; :Returns: number`,
          `;`,
          `;`,
          `;`,
          `;-`,
          `function myfunc, var1`,
          `  compile_opt idl2`,
          `  return, 1`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Detects when the returns tag has too much information (NOT HANDLED FOR LEGACY, regression test)`,
    fileName: `code.61.docs-return-invalid.idldoc-legacy.spec.ts`,
    tests: [
      {
        name: `no problems`,
        code: [
          `;+`,
          `; @param var1 My favorite argument`,
          `;`,
          `; @returns number`,
          `;-`,
          `function myfunc, var1`,
          `  compile_opt idl2`,
          `  return, 1`,
          `end`,
        ],
      },
      {
        name: `problem`,
        code: [
          `;+`,
          `; @param var1 My favorite argument`,
          `;`,
          `; @returns number`,
          `;   Fun fact about zach`,
          `;   he is a vegetarian`,
          `;-`,
          `function myfunc, var1`,
          `  compile_opt idl2`,
          `  return, 1`,
          `end`,
        ],
      },
      {
        name: `no problem with extra spaces`,
        code: [
          `;+`,
          `; @param var1 My favorite argument`,
          `;`,
          `; @returns number`,
          `;`,
          `;`,
          `;`,
          `;-`,
          `function myfunc, var1`,
          `  compile_opt idl2`,
          `  return, 1`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Detects when the returns tag is present for procedures`,
    fileName: `code.62.docs-return-not-needed.spec.ts`,
    tests: [
      {
        name: `no problems`,
        code: [
          `;+`,
          `; :Params:`,
          `;   var1: in, optional, boolean, public`,
          `;     My favorite argument`,
          `;-`,
          `pro myroutine, var1`,
          `  compile_opt idl2`,
          `end`,
        ],
      },
      {
        name: `problem`,
        code: [
          `;+`,
          `; :Params:`,
          `;   var1: in, optional, boolean, public`,
          `;     My favorite argument`,
          `; :Returns: number`,
          `;-`,
          `pro myroutine, var1`,
          `  compile_opt idl2`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Detects when the returns tag is present for procedures`,
    fileName: `code.62.docs-return-not-needed.idldoc-legacy.spec.ts`,
    tests: [
      {
        name: `no problems`,
        code: [
          `;+`,
          `; @param var1 My favorite argument`,
          `;-`,
          `pro myroutine, var1`,
          `  compile_opt idl2`,
          `end`,
        ],
      },
      {
        name: `problem`,
        code: [
          `;+`,
          `; @param var1 My favorite argument`,
          `;`,
          `; @returns number`,
          `;-`,
          `pro myroutine, var1`,
          `  compile_opt idl2`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Detects when a documented parameter does not exist in routine definition`,
    fileName: `code.63.docs-not-real-param.spec.ts`,
    tests: [
      {
        name: `no problems`,
        code: [
          `;+`,
          `; My procedure`,
          `;`,
          `; :Args:`,
          `;  var1: in, required, any`,
          `;    My favorite thing`,
          `;`,
          `; :Keywords:`,
          `;  kw1: in, optional, type=boolean`,
          `;    Super Cool flag`,
          `;`,
          `;-`,
          `pro mypro, var1, KW1=kw1`,
          `  compile_opt idl2`,
          `end`,
        ],
      },
      {
        name: `problem with args and keywords`,
        code: [
          `;+`,
          `; My procedure`,
          `;`,
          `; :Args:`,
          `;  var1: in, required, any`,
          `;    My favorite thing`,
          `;`,
          `; :Keywords:`,
          `;  kw1: in, optional, type=boolean`,
          `;    Super Cool flag`,
          `;`,
          `;-`,
          `pro mypro, var2, KW2=kw2`,
          `  compile_opt idl2`,
          `end`,
        ],
      },
      {
        name: `do not mistake colons in the description as parameters`,
        code: [
          `;+`,
          `; My procedure`,
          `;`,
          `; :Args:`,
          `;  var1: in, required, any`,
          `;    My favorite thing: something else`,
          `;`,
          `; :Keywords:`,
          `;  kw1: in, optional, type=boolean`,
          `;    Super Cool flag: something else`,
          `;`,
          `;-`,
          `pro mypro, var1, KW1=kw1`,
          `  compile_opt idl2`,
          `end`,
        ],
      },
      {
        name: `detect in structures`,
        code: [
          `;+`,
          `; :MyStruct:`,
          `;   prop: any`,
          `;     Placeholder docs for argument or keyword`,
          `;   prop3: any`,
          `;     Placeholder docs for argument or keyword`,
          `;`,
          `;-`,
          `pro pro4__define`,
          `  compile_opt idl2`,
          ``,
          `  !null = {MyStruct, inherits IDL_object, prop: 1}`,
          ``,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Detects when a documented parameter does not exist in routine definition`,
    fileName: `code.63.docs-not-real-param.idldoc-legacy.spec.ts`,
    tests: [
      {
        name: `no problems`,
        code: [
          `;+`,
          `; My procedure`,
          `;`,
          `; @param var1 My favorite thing`,
          `;`,
          `; @keyword kw1 Super Cool Flag`,
          `;`,
          `;-`,
          `pro mypro, var1, KW1=kw1`,
          `  compile_opt idl2`,
          `end`,
        ],
      },
      {
        name: `problem with args and keywords`,
        code: [
          `;+`,
          `; My procedure`,
          `;`,
          `; @param var1 My favorite thing`,
          `; @param var2 My favorite thing`,
          `;`,
          `; @keyword kw1 Super Cool Flag`,
          `; @keyword kw2 Super Cool Flag`,
          `;`,
          `;-`,
          `pro mypro, var2, KW2=kw2`,
          `  compile_opt idl2`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Detects when a defined parameter is missing from user docs`,
    fileName: `code.64.docs-param-missing.spec.ts`,
    tests: [
      {
        name: `no problems`,
        code: [
          `;+`,
          `; My procedure`,
          `;`,
          `; :Args:`,
          `;  var1: in, required, any`,
          `;    My favorite thing`,
          `;`,
          `; :Keywords:`,
          `;  kw1: in, optional, type=boolean`,
          `;    Super Cool flag`,
          `;`,
          `;-`,
          `pro mypro, var1, KW1=kw1`,
          `  compile_opt idl2`,
          `end`,
        ],
      },
      {
        name: `problem with args and keywords`,
        code: [
          `;+`,
          `; My procedure`,
          `;`,
          `; :Args:`,
          `;`,
          `; :Keywords:`,
          `;`,
          `;-`,
          `pro mypro, var1, KW1=kw1`,
          `  compile_opt idl2`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Detects when a defined parameter is missing from user docs`,
    fileName: `code.64.docs-param-missing.idldoc-legacy.spec.ts`,
    tests: [
      {
        name: `no problems`,
        code: [
          `;+`,
          `; My procedure`,
          `;`,
          `; @param var1 My favorite thing`,
          `;`,
          `; @keyword kw1 Super Cool Flag`,
          `;`,
          `;-`,
          `pro mypro, var1, KW1=kw1`,
          `  compile_opt idl2`,
          `end`,
        ],
      },
      {
        name: `problem with args and keywords`,
        code: [
          `;+`,
          `; My procedure`,
          `;`,
          `; @param var1 My favorite thing`,
          `;`,
          `; @keyword kw1 Super Cool Flag`,
          `;`,
          `;-`,
          `pro mypro, var1, var2, KW1=kw1, KW2=kw2`,
          `  compile_opt idl2`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Detects when a string literal has too many arguments`,
    fileName: `code.65.string-literal-too-many-args.spec.ts`,
    tests: [
      {
        name: `no problems`,
        code: '`${1.234,"%10.3f"}`',
      },
      {
        name: `no problems - string literal in formatting`,
        code: '`${1.234,`%${w}.3f`}`',
      },
      {
        name: `problem with too many args`,
        code: '`${1.234,abc,"%10.3f"}`',
      },
    ],
  },
  {
    suiteName: `Detects bad continue statements`,
    fileName: `code.66.bad-continue.spec.ts`,
    tests: [
      {
        name: `no problems in loops`,
        code: [
          `compile_opt idl2`,
          `for i=0,10 do if !true then continue`,
          `foreach val, key do if !true then continue`,
          `while !true do if !false then continue`,
          `repeat if !true then continue until !true`,
          `end`,
        ],
      },
      {
        name: `problems outside of loops`,
        code: [`compile_opt idl2`, `continue`, `end`],
      },
    ],
  },
  {
    suiteName: `Detects bad break statements`,
    fileName: `code.67.bad-break.spec.ts`,
    tests: [
      {
        name: `no problems in loops`,
        code: [
          `compile_opt idl2`,
          `for i=0,10 do if !true then break`,
          `foreach val, key do if !true then break`,
          `while !true do if !false then break`,
          `repeat if !true then break until !true`,
          `end`,
        ],
      },
      {
        name: `no problems in switch`,
        code: [
          `compile_opt idl2`,
          `switch a of`,
          `  !true: break`,
          `endswitch`,
          `end`,
        ],
      },
      {
        name: `no problems in case`,
        code: [
          `compile_opt idl2`,
          `case a of`,
          `  !true: break`,
          `endcase`,
          `end`,
        ],
      },
      {
        name: `problems outside of loops`,
        code: [`compile_opt idl2`, `break`, `end`],
      },
    ],
  },
  {
    suiteName: `Detects tokens that are empty but shouldn't be`,
    fileName: `code.68.expected-statement.spec.ts`,
    tests: [
      {
        name: `problem in assignment`,
        code: [`compile_opt idl2`, `a = `, `end`],
      },
      {
        name: `problem in basic operators`,
        code: [`compile_opt idl2`, `a = 42 +`, `end`],
      },
      {
        name: `problem in compound operator`,
        code: [`compile_opt idl2`, `a *= `, `end`],
      },
      {
        name: `problem in logical operator`,
        code: [`compile_opt idl2`, `a = 5 and `, `end`],
      },
      {
        name: `problem in negative sign`,
        code: [`compile_opt idl2`, `a = - `, `end`],
      },
      {
        name: `problem in pointer dereference`,
        code: [`compile_opt idl2`, `a = *`, `end`],
      },
      {
        name: `problem in parentheses`,
        code: [`compile_opt idl2`, `a = ()`, `end`],
      },
      {
        name: `problem in for`,
        code: [`compile_opt idl2`, `for`, `end`],
      },
      {
        name: `problem in foreach`,
        code: [`compile_opt idl2`, `foreach`, `end`],
      },
      {
        name: `problem in foreach`,
        code: [`compile_opt idl2`, `while`, `end`],
      },
      {
        name: `problem in foreach`,
        code: [`compile_opt idl2`, `for i=0,1 do`, `end`],
      },
      {
        name: `problem in repeat`,
        code: [`compile_opt idl2`, `repeat`, `end`],
      },
      {
        name: `problem in until`,
        code: [`compile_opt idl2`, `repeat a = 5 until`, `end`],
      },
      {
        name: `problem in if`,
        code: [`compile_opt idl2`, `if`, `end`],
      },
      {
        name: `problem in then`,
        code: [`compile_opt idl2`, `if !true then`, `end`],
      },
      {
        name: `problem in else`,
        code: [`compile_opt idl2`, `if !true then a = 42 else`, `end`],
      },
      {
        name: `problem in ternary then`,
        code: [`compile_opt idl2`, `a = !true ?`, `end`],
      },
      {
        name: `problem in ternary else`,
        code: [`compile_opt idl2`, `a = !true ? 42 :`, `end`],
      },
      {
        name: `problem in switch`,
        code: [`compile_opt idl2`, `switch`, `end`],
      },
      {
        name: `problem in case`,
        code: [`compile_opt idl2`, `case`, `end`],
      },
      {
        name: `problem in of for switch`,
        code: [`compile_opt idl2`, `switch !true of`, `end`],
      },
      {
        name: `problem in of for case`,
        code: [`compile_opt idl2`, `switch !true of`, `end`],
      },
    ],
  },
  {
    suiteName: `Detects tokens that are empty but shouldn't be`,
    fileName: `code.69.unfinished-dot.spec.ts`,
    tests: [
      {
        name: 'as procedure-method or property access, but incomplete',
        code: [`compile_opt idl2`, `a.`, `end`],
      },
      {
        name: 'as function method or property access, but incomplete',
        code: [`compile_opt idl2`, `a = b.`, `end`],
      },
      {
        name: 'standalone 1',
        code: [`compile_opt idl2`, `a = .`, `end`],
      },
      {
        name: 'standalone 2',
        code: [`compile_opt idl2`, `.`, `end`],
      },
    ],
  },
  {
    suiteName: `Verify string literal escape characters`,
    fileName: `code.70.illegal-hex-escape.spec.ts`,
    tests: [
      {
        name: `only have a problem with the last one`,
        code: [
          `compile_opt idl2`,
          `a = \`\\\`\``,
          `a = \`\\$\``,
          `a = \`\\\\\``,
          `a = \`\\b\``,
          `a = \`\\f\``,
          `a = \`\\n\``,
          `a = \`\\r\``,
          `a = \`\\t\``,
          `a = \`\\v\``,
          `a = \`\\x00 \\XaF\``,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Find unknown string literal escape characters`,
    fileName: `code.71.unknown-template-escape.spec.ts`,
    tests: [
      {
        name: `no problems with all good`,
        code: [
          `compile_opt idl2`,
          `a = \`\\\`\``,
          `a = \`\\$\``,
          `a = \`\\\\\``,
          `a = \`\\b\``,
          `a = \`\\f\``,
          `a = \`\\n\``,
          `a = \`\\r\``,
          `a = \`\\t\``,
          `a = \`\\v\``,
          `a = \`\\x00\``,
          `end`,
        ],
      },
      {
        name: `problems with incomplete and bad ones`,
        code: [
          `compile_opt idl2`,
          `a = \`\\ \``,
          `a = \`\\a\``,
          `a = \`\\42\``,
          `a = \`\\lark \\r\\n\``,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Find duplicate arg and keyword variables and detect`,
    fileName: `code.72.duplicate-arg-kw-var-def.spec.ts`,
    tests: [
      {
        name: `no problems when OK`,
        code: [
          `pro mypro, a, b, AKW = akw, BKW = bkw`,
          `  compile_opt idl2`,
          `end`,
        ],
      },
      {
        name: `problems in procedures`,
        code: [`pro mypro, a, a, b, B = b, C = b`, `  compile_opt idl2`, `end`],
      },
      {
        name: `problems in procedure methods`,
        code: [
          `pro myclass::mymethod, a, a, b, B = b, C = b`,
          `  compile_opt idl2`,
          `end`,
        ],
      },
      {
        name: `problems in functions`,
        code: [
          `function myfunc, a, a, b, B = b, C = b`,
          `  compile_opt idl2`,
          `  return, 1`,
          `end`,
        ],
      },
      {
        name: `problems in function methods`,
        code: [
          `function myclass::mymethod, a, a, b, B = b, C = b`,
          `  compile_opt idl2`,
          `  return, 1`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Find duplicate keyword definitions`,
    fileName: `code.73.duplicate-kw-def.spec.ts`,
    tests: [
      {
        name: `no problems when OK`,
        code: [`pro mypro, AKW = akw, BKW = bkw`, `  compile_opt idl2`, `end`],
      },
      {
        name: `problems in procedures`,
        code: [`pro mypro, AKW = akw, AKW = bkw`, `  compile_opt idl2`, `end`],
      },
      {
        name: `problems in procedure methods`,
        code: [
          `pro myclass::mypro, AKW = akw, AKW = bkw`,
          `  compile_opt idl2`,
          `end`,
        ],
      },
      {
        name: `problems in functions`,
        code: [
          `function myfunc, AKW = akw, AKW = bkw`,
          `  compile_opt idl2`,
          `  return, 1`,
          `end`,
        ],
      },
      {
        name: `problems in function methods`,
        code: [
          `function myfunc::mymethod, AKW = akw, AKW = bkw`,
          `  compile_opt idl2`,
          `  return, 1`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Find duplicate properties and find`,
    fileName: `code.74.duplicate-property.spec.ts`,
    tests: [
      {
        name: `no problems when OK`,
        code: [
          `; main level program`,
          `compile_opt idl2`,
          `a = {a:a, B      :b}`,
          `end`,
        ],
      },
      {
        name: `problems when we have them`,
        code: [
          `; main level program`,
          `compile_opt idl2`,
          `a = {a:a, A      :b}`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Find keyword usage and detect problems in`,
    fileName: `code.75.duplicate-kw-usage.spec.ts`,
    tests: [
      {
        name: `procedures`,
        code: [
          `; main level program`,
          `compile_opt idl2`,
          `plot, kw1=5, KW1=5, kw1=5, /KW1`,
          `end`,
        ],
      },
      {
        name: `procedure methods`,
        code: [
          `; main level program`,
          `compile_opt idl2`,
          `a.plot, kw1=5, KW1=5, kw1=5, /KW1`,
          `end`,
        ],
      },
      {
        name: `functions`,
        code: [
          `; main level program`,
          `compile_opt idl2`,
          `a = plot(kw1=5, KW1=5, kw1=5, /KW1)`,
          `end`,
        ],
      },
      {
        name: `function methods`,
        code: [
          `; main level program`,
          `compile_opt idl2`,
          `a = b.plot(kw1=5, KW1=5, kw1=5, /KW1)`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Check for init methods`,
    fileName: `code.76.init-method-pro.spec.ts`,
    tests: [
      {
        name: `being procedures incorrectly`,
        code: [`pro mypro::init`, `  compile_opt idl2`, ``, `end`],
      },
    ],
  },
  {
    suiteName: `Check for structure names`,
    fileName: `code.77.unknown-structure.spec.ts`,
    tests: [
      {
        name: `reported not in class definitions`,
        code: [
          `pro auto_doc_example`,
          `  compile_opt idl2`,
          `  a = {ENVIRaster2}`,
          `end`,
        ],
      },
      {
        name: `ignored in class definitions`,
        code: [
          `pro auto_doc_example__define`,
          `  compile_opt idl2`,
          `  a = {ENVIRaster2}`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Check for bad access`,
    fileName: `code.78.illegal-chain.spec.ts`,
    tests: [
      {
        name: `from function calls`,
        code: [
          `pro so_bad`,
          `  compile_opt idl2`,
          `  a = myfunc().ohNo`,
          `  a = myfunc().(42)`,
          `  myfunc().ohMeOhMy`,
          `  a = myfunc().ohNotOk()`,
          `end`,
        ],
      },
      {
        name: `from function method calls`,
        code: [
          `pro so_sad`,
          `  compile_opt idl2`,
          `  a = var.myfunc().ohNo`,
          `  a = var.myfunc().(42)`,
          `  var.myfunc().ohMeOhMy`,
          `  a = var.myfunc().ohNotOk()`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Check for missing structure definitions`,
    fileName: `code.79.docs-missing-struct.spec.ts`,
    tests: [
      {
        name: `from docs 1`,
        code: [
          `;+`,
          `;-`,
          `pro pro4__define`,
          `  compile_opt idl2`,
          ``,
          `  !null = {MyStruct, inherits IDL_object, prop: 1, prop2: 4}`,
          ``,
          `  !null = {mystruct2, inherits IDL_object, prop: 1, prop2: 4}`,
          ``,
          `end`,
        ],
      },
      {
        name: `from docs 2`,
        code: [
          `;+`,
          `; :MyStruct:`,
          `;   prop: any`,
          `;     Placeholder docs for argument or keyword`,
          `;   prop2:any`,
          `;     Placeholder docs for argument or keyword`,
          `;`,
          `;-`,
          `pro pro4__define`,
          `  compile_opt idl2`,
          ``,
          `  !null = {MyStruct, inherits IDL_object, prop: 1, prop2: 4}`,
          ``,
          `  !null = {mystruct2, inherits IDL_object, prop: 1, prop2: 4}`,
          ``,
          `end`,
        ],
      },
      {
        name: `ignore when no docs`,
        code: [
          `pro pro4__define`,
          `  compile_opt idl2`,
          ``,
          `  !null = {MyStruct, inherits IDL_object, prop: 1, prop2: 4}`,
          ``,
          `end`,
        ],
      },
      {
        name: `ignore when just procedure`,
        code: [
          `;+`,
          `;-`,
          `pro pro4`,
          `  compile_opt idl2`,
          ``,
          `  !null = {MyStruct, inherits IDL_object, prop: 1, prop2: 4}`,
          ``,
          `  !null = {mystruct2, inherits IDL_object, prop: 1, prop2: 4}`,
          ``,
          `end`,
        ],
      },
      {
        name: `ignore when function`,
        code: [
          `function myfunc`,
          `  compile_opt idl2`,
          ``,
          `  !null = {MyStruct, inherits IDL_object, prop: 1, prop2: 4}`,
          ``,
          `  !null = {mystruct2, inherits IDL_object, prop: 1, prop2: 4}`,
          ``,
          `  return, 1`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Check for missing properties`,
    fileName: `code.80.docs-missing-prop.spec.ts`,
    tests: [
      {
        name: `in our docs`,
        code: [
          `;+`,
          `; :MyStruct:`,
          `;   prop: any`,
          `;     Placeholder docs for argument or keyword`,
          `;`,
          `;-`,
          `pro pro4__define`,
          `  compile_opt idl2`,
          ``,
          `  !null = {MyStruct, inherits IDL_object, prop: 1, prop2: 4}`,
          ``,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Check for args and keywords in procedure class definitions`,
    fileName: `code.81.class-no-params.spec.ts`,
    tests: [
      {
        name: `with arg`,
        code: [`pro pro4__define, a`, `  compile_opt idl2`, ``, `end`],
      },
      {
        name: `with kw`,
        code: [`pro pro4__define, KW = kw`, `  compile_opt idl2`, ``, `end`],
      },
      {
        name: `with both`,
        code: [
          `pro pro4__define, arg, KW = kw`,
          `  compile_opt idl2`,
          ``,
          `end`,
        ],
      },
      {
        name: `ok with neither`,
        code: [`pro pro4__define`, `  compile_opt idl2`, ``, `end`],
      },
    ],
  },
  {
    suiteName: `Not enough parameters for properties`,
    fileName: `code.82.docs-prop-too-few-params.spec.ts`,
    tests: [
      {
        name: `without anything`,
        code: [
          `;+`,
          `; :NYStruct0:`,
          `;   prop1:`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;`,
          `; :NYStruct:`,
          `;   prop2:  `,
          `;     Placeholder docs for argument, keyword, or property`,
          `;`,
          `;-`,
          `pro pro3__define`,
          `  compile_opt idl3`,
          ``,
          `  !null = {NYStruct0, prop1: 5}`,
          ``,
          `  !null = {NYStruct, inherits NYStruct0, prop2: 6}`,
          `end`,
        ],
      },
      {
        name: `no problems`,
        code: [
          `;+`,
          `; :NYStruct0:`,
          `;   prop1: any`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;`,
          `; :NYStruct:`,
          `;   prop2: String | number`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;`,
          `;-`,
          `pro pro3__define`,
          `  compile_opt idl3`,
          ``,
          `  !null = {NYStruct0, prop1: 5}`,
          ``,
          `  !null = {NYStruct, inherits NYStruct0, prop2: 6}`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Too many parameters for properties`,
    fileName: `code.83.docs-prop-too-many-params.spec.ts`,
    tests: [
      {
        name: `with extra`,
        code: [
          `;+`,
          `; :NYStruct0:`,
          `;   prop1: any, bad`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;`,
          `; :NYStruct:`,
          `;   prop2: String, noop`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;`,
          `;-`,
          `pro pro3__define`,
          `  compile_opt idl3`,
          ``,
          `  !null = {NYStruct0, prop1: 5}`,
          ``,
          `  !null = {NYStruct, inherits NYStruct0, prop2: 6}`,
          `end`,
        ],
      },
      {
        name: `no problems`,
        code: [
          `;+`,
          `; :NYStruct0:`,
          `;   prop1: Hash<String, Number>`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;`,
          `; :NYStruct:`,
          `;   prop2: String`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;`,
          `;-`,
          `pro pro3__define`,
          `  compile_opt idl3`,
          ``,
          `  !null = {NYStruct0, prop1: 5}`,
          ``,
          `  !null = {NYStruct, inherits NYStruct0, prop2: 6}`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Illegal subscript`,
    fileName: `code.84.illegal-subscript.spec.ts`,
    tests: [
      {
        name: `operations`,
        code: [
          `;+`,
          `; :Arguments:`,
          `;   arg1: in, required, Array<Number | String>`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;   arg2: in, required, List<Number>`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;   arg3: in, required, Hash<any>`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;   arg4: in, required, OrderedHash<Byte>`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;   arg5: in, required, Dictionary<ENVIRaster>`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;`,
          `;-`,
          `pro index_problems, arg1, arg2, arg3, arg4, arg5`,
          `  compile_opt idl3`,
          ``,
          `  ; for arrays`,
          `  a1 = arg1[*]`,
          `  a2 = arg1[0, 1, *]`,
          `  a3 = arg1[0, 1, 2]`,
          `  a4 = arg1[0 : -1 : 1]`,
          `  a5 = arg1[0, 1, *]`,
          ``,
          `  ; for lists`,
          `  l1 = arg2[*]`,
          `  l2 = arg2[0, 1, *]`,
          `  l3 = arg2[0, 1, 2]`,
          `  l4 = arg2[0 : -1 : 1]`,
          `  l5 = arg2[0, 1, *]`,
          ``,
          `  ; for hashes`,
          `  h1 = arg3[*]`,
          `  h2 = arg3[0, 1, *]`,
          `  h3 = arg3[0, 1, 2]`,
          `  h4 = arg3[0 : -1 : 1]`,
          `  h5 = arg3[0, 1, *]`,
          ``,
          `  ; for ordered hashes`,
          `  oh1 = arg4[*]`,
          `  oh2 = arg4[0, 1, *]`,
          `  oh3 = arg4[0, 1, 2]`,
          `  oh4 = arg4[0 : -1 : 1]`,
          `  oh5 = arg4[0, 1, *]`,
          ``,
          `  ; for dictionaries`,
          `  d1 = arg5[*]`,
          `  d2 = arg5[0, 1, *]`,
          `  d3 = arg5[0, 1, 2]`,
          `  d3 = arg5[0 : -1 : 1]`,
          `  d5 = arg5[0, 1, *]`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Illegal structure`,
    fileName: `code.85.illegal-struct-op.spec.ts`,
    tests: [
      {
        name: `operations`,
        code: [
          `pro struct_checks`,
          `compile_opt idl2`,
          ``,
          `str = {a: 42}`,
          ``,
          `a = 1 + str`,
          ``,
          `b = str + {a: 42}`,
          ``,
          `c = str + list()`,
          ``,
          `d = str + hash()`,
          ``,
          `e = str + orderedhash()`,
          ``,
          `f = str + dictionary()`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Illegal list`,
    fileName: `code.86.illegal-list-op.spec.ts`,
    tests: [
      {
        name: `operations`,
        code: [
          `pro list_checks`,
          `compile_opt idl2`,
          ``,
          `a = 1 + list()`,
          ``,
          `b = list() + list()`,
          ``,
          `c = list() + hash()`,
          ``,
          `d = list() + orderedhash()`,
          ``,
          `e = list() + dictionary()`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Illegal hash`,
    fileName: `code.87.illegal-hash-op.spec.ts`,
    tests: [
      {
        name: `operations`,
        code: [
          `pro hash_checks`,
          `compile_opt idl2`,
          ``,
          `a = 1 + hash()`,
          ``,
          `b = hash() + list()`,
          ``,
          `c = hash() + hash()`,
          ``,
          `d = hash() + orderedhash()`,
          ``,
          `e = hash() + dictionary()`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Illegal ordered hash`,
    fileName: `code.88.illegal-ordered-hash-op.spec.ts`,
    tests: [
      {
        name: `operations`,
        code: [
          `pro orderedhash_checks`,
          `compile_opt idl2`,
          ``,
          `a = 1 + orderedhash()`,
          ``,
          `b = orderedhash() + list()`,
          ``,
          `c = orderedhash() + hash()`,
          ``,
          `d = orderedhash() + orderedhash()`,
          ``,
          `e = orderedhash() + dictionary()`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Illegal dictionary`,
    fileName: `code.89.illegal-dictionary-op.spec.ts`,
    tests: [
      {
        name: `operations`,
        code: [
          `pro dictionary_checks`,
          `compile_opt idl2`,
          ``,
          `a = 1 + dictionary()`,
          ``,
          `b = dictionary() + list()`,
          ``,
          `c = dictionary() + hash()`,
          ``,
          `d = dictionary() + orderedhash()`,
          ``,
          `e = dictionary() + dictionary()`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Potential type incompatibility in`,
    fileName: `code.90.potential-type-incompatibility.spec.ts`,
    tests: [
      {
        name: `operations`,
        code: [
          `pro incompatible_checks`,
          `compile_opt idl2`,
          ``,
          `a = 1 + ENVIRaster()`,
          ``,
          `b = 1 + plot()`,
          `end`,
        ],
      },
      {
        name: `no problems with array creation`,
        code: [
          `pro incompatible_checks`,
          `compile_opt idl2`,
          ``,
          `arr1 = [ENVIRaster(), ENVIMetaspectralRaster(), ENVISubsetRaster()]`,
          `arr2 = [{}, {}]`,
          `end`,
        ],
      },
      {
        name: `problems with array creation`,
        code: [
          `pro incompatible_checks`,
          `compile_opt idl2`,
          ``,
          `bad1 = [ENVIRaster(), {}]`,
          `bad2 = [{}, 1]`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Illegal index checks for`,
    fileName: `code.91.illegal-index-type.spec.ts`,
    tests: [
      {
        name: `all types`,
        code: [
          `;+`,
          `; :Arguments:`,
          `;   arg1: in, required, Array<Number | String>`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;   arg2: in, required, List<Number>`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;   arg3: in, required, Hash<any>`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;   arg4: in, required, OrderedHash<Byte>`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;   arg5: in, required, Dictionary<ENVIRaster>`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;`,
          `;-`,
          `pro index_problems, arg1, arg2, arg3, arg4, arg5`,
          `  compile_opt idl3`,
          ``,
          `  ; for arrays`,
          `  !null = arg1[plot()]`,
          `  !null = arg1[1j]`,
          `  !null = arg1[1i]`,
          `  !null = arg1[1di]`,
          `  !null = arg1[1dj]`,
          ``,
          `  ; for lists`,
          `  !null = arg2[plot()]`,
          `  !null = arg2[1j]`,
          `  !null = arg2[1i]`,
          `  !null = arg2[1di]`,
          `  !null = arg2[1dj]`,
          ``,
          `  ; for hashes`,
          `  !null = arg3[plot()]`,
          `  !null = arg3[1j]`,
          `  !null = arg3[1i]`,
          `  !null = arg3[1di]`,
          `  !null = arg3[1dj]`,
          ``,
          `  ; for ordered hashes`,
          `  !null = arg4[plot()]`,
          `  !null = arg4[1j]`,
          `  !null = arg4[1i]`,
          `  !null = arg4[1di]`,
          `  !null = arg4[1dj]`,
          ``,
          `  ; for dictionaries`,
          `  !null = arg5[plot()]`,
          `  !null = arg5[1j]`,
          `  !null = arg5[1i]`,
          `  !null = arg5[1di]`,
          `  !null = arg5[1dj]`,
          `end`,
        ],
      },
      {
        name: `allow boolean since it is really a number`,
        code: [
          `pro index_problems`,
          `  compile_opt idl2`,
          ``,
          `  ; for arrays`,
          `  display = strarr(c)`,
          `  i = keyword_set(!null)`,
          `  !null = display[i]`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Array data type incompatibility`,
    fileName: `code.92.potential-arr-type-incompatibility.spec.ts`,
    tests: [
      {
        name: `operations`,
        code: [
          `;+`,
          `; :Arguments:`,
          `;   arg1: in, required, Array<Number | String>`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;   arg4: in, required, Array<Byte>`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;   arg5: in, required, Array<ENVIRaster>`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;`,
          `;-`,
          `pro array_incompatibility, arg1, arg4, arg5`,
          `  compile_opt idl2`,
          ``,
          `  ; OK`,
          `  a = arg1 + arg4`,
          ``,
          `  ; bad`,
          `  b = arg1 + arg4 + arg5`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `De-referencing noting`,
    fileName: `code.93.ptr-nothing-to-de-ref.spec.ts`,
    tests: [
      {
        name: `with asterisks`,
        code: [
          `pro mypro`,
          `  compile_opt idl2`,
          ``,
          `  ; yikes`,
          `  a = *`,
          ``,
          `  ; bad`,
          `  b = (*)`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Pointer de-ref without pointers`,
    fileName: `code.94.ptr-de-ref-illegal.spec.ts`,
    tests: [
      {
        name: `operations`,
        code: [
          `;+`,
          `; :Arguments:`,
          `;   arg1: in, required, Pointer<Number>`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;   arg2: in, required, Array<Number>`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;   arg3: in, required, Array<Pointer<ENVIRaster>>`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;   arg4: in, required, Pointer<Number> | String`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;   arg5: in, required, Pointer<any>`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;   arg6: in, required, Pointer<String> | Pointer<Number>`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;`,
          `;-`,
          `pro pointers, arg1, arg2, arg3, arg4, arg5, arg6`,
          `  compile_opt idl3`,
          ``,
          `  ; number`,
          `  a = *arg1`,
          ``,
          `  ; enviraster`,
          `  b = *arg3[0]`,
          ``,
          `  ; any, unable to de-reference`,
          `  d = *5`,
          ``,
          `  ; any`,
          `  f = *arg5`,
          ``,
          `  ; union of type args`,
          `  g = *arg6`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Errors for indexing`,
    fileName: `code.95.indexing-error.spec.ts`,
    tests: [
      {
        name: `variables that cannot be indexed`,
        code: [
          `;+`,
          `; :Returns:`,
          `;   any`,
          `;`,
          `; :Arguments:`,
          `;   a: in, required, Number`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;   b: in, required, ComplexNumber`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;   c: in, required, Array<any>`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;   d: in, required, List<any>`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;   e: in, required, Hash<any>`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;   f: in, required, OrderedHash<any>`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;   g: in, required, Dictionary<any>`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;   h: in, required, ENVIRasterMetadata`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;`,
          `;-`,
          `function allowed_to_index, a, b, c, d, e, f, g, h`,
          `  compile_opt idl2`,
          ``,
          `  ; OK`,
          `  !null = c[0]`,
          `  !null = d[0]`,
          `  !null = e[0]`,
          `  !null = f[0]`,
          `  !null = g[0]`,
          ``,
          `  ; also OK, though non standard IDL types`,
          `  !null = h[0]`,
          ``,
          `  ; problems`,
          `  byte = ('s' + 1b)[0]`,
          `  int = ('s' + 1s)[0]`,
          `  uint = ('s' + 1us)[0]`,
          `  long = ('s' + 1l)[0]`,
          `  ulong = ('s' + 1ul)[0]`,
          `  long64 = ('s' + 1ll)[0]`,
          `  ulong64 = ('s' + 1ull)[0]`,
          `  float1 = ('s' + 1.)[0]`,
          `  float2 = ('s' + 1e)[0]`,
          `  double = ('s' + 1d)[0]`,
          `  biginteger = ('s' + BigInteger(5))[0]`,
          `  number = ('s' + a)[0]`,
          `  complexfloat = ('s' + 1.i)[0]`,
          `  complexdouble = ('s' + 1di)[0]`,
          `  complexdouble = ('s' + 1dj)[0]`,
          `  complexnumber1 = ('s' + a + 1di + 1dj)[0]`,
          `  complexnumber2 = (a + b)[0]`,
          ``,
          `  return, 1`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Pointer de-ref without pointers`,
    fileName: `code.96.ptr-de-ref-ambiguity.spec.ts`,
    tests: [
      {
        name: `operations`,
        code: [
          `;+`,
          `; :Arguments:`,
          `;   arg1: in, required, Pointer<Number>`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;   arg2: in, required, Array<Number>`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;   arg3: in, required, Array<Pointer<ENVIRaster>>`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;   arg4: in, required, Pointer<Number> | String`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;   arg5: in, required, Pointer<any>`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;   arg6: in, required, Pointer<String> | Pointer<Number>`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;`,
          `;-`,
          `pro pointers, arg1, arg2, arg3, arg4, arg5, arg6`,
          `  compile_opt idl3`,
          ``,
          `  ; number`,
          `  a = *arg1`,
          ``,
          `  ; enviraster`,
          `  b = *arg3[0]`,
          ``,
          `  ; ambiguous`,
          `  c = *arg4`,
          ``,
          `  ; any`,
          `  f = *arg5`,
          ``,
          `  ; union of type args`,
          `  g = *arg6`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Check for known keywords`,
    fileName: `code.97.unknown-kw.spec.ts`,
    tests: [
      {
        name: `and report errors if we dont have "_extra" or "_ref_extra"`,
        code: [
          `;+`,
          `; :Description:`,
          `;   Constructor`,
          `;`,
          `; :Returns:`,
          `;   myclass`,
          `;`,
          `;-`,
          `function myclass::Init`,
          `  compile_opt idl2`,
          ``,
          `  return, 1`,
          `end`,
          ``,
          `;+`,
          `; :Returns:`,
          `;   any`,
          `;`,
          `; :Keywords:`,
          `;   kw: out, optional, Array<Number>`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;`,
          `;-`,
          `function myclass::method, kw = kw, _ref_extra = _extra`,
          `  compile_opt idl2`,
          `  return, 1`,
          `end`,
          ``,
          `;+`,
          `; :Keywords:`,
          `;   kw: out, optional, ENVIRaster`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;`,
          `;-`,
          `pro myclass::method, kw = kw, _extra = _extra`,
          `  compile_opt idl2`,
          `end`,
          ``,
          `;+`,
          `; :Description:`,
          `;   Class definition procedure`,
          `;`,
          `;-`,
          `pro myclass__define`,
          `  compile_opt idl2`,
          ``,
          `  struct = {myclass}`,
          `end`,
          ``,
          `;+`,
          `; :Returns:`,
          `;   any`,
          `;`,
          `; :Keywords:`,
          `;   kw: out, optional, Long`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;`,
          `;-`,
          `function myfunc, kw = kw`,
          `  compile_opt idl2`,
          `  return, 1`,
          `end`,
          ``,
          `;+`,
          `; :Keywords:`,
          `;   kw: out, optional, Byte`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;`,
          `;-`,
          `pro mypro, kw = kw`,
          `  compile_opt idl2`,
          ``,
          `end`,
          ``,
          `; main level program`,
          `compile_opt idl2`,
          ``,
          `; procedures`,
          `mypro, kw = a, /kw2, kw3 = 3`,
          ``,
          `; functions`,
          `!null = myfunc(kw = b, /kw2, kw3 = 3)`,
          ``,
          `; make class for methods`,
          `var = myclass()`,
          ``,
          `; procedure methods`,
          `var.method, kw = c, /kw2, kw3 = 3`,
          ``,
          `; function methods`,
          `!null = var.method(kw = d, /kw2, kw3 = 3)`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Check for known keywords`,
    fileName: `code.97.unknown-kw.exceptions.spec.ts`,
    tests: [
      {
        name: `and exclude these cases`,
        code: [
          `; main level program`,
          `compile_opt idl2`,
          ``,
          `; procedures`,
          `p = plot(/tes)`,
          `end`,
        ],
      },
      {
        name: `unless we have extra or ref extra (only one at a time)`,
        code: [
          `;+`,
          `; :Keywords:`,
          `;   _ref_extra: bidirectional, optional, any`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;`,
          `;-`,
          `pro auto_doc_example2, _ref_extra = ex`,
          `  compile_opt idl2`,
          ``,
          `end`,
          ``,
          `;+`,
          `; :Keywords:`,
          `;   _extra: bidirectional, optional, any`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;`,
          `;-`,
          `pro auto_doc_example, _extra = ex`,
          `  compile_opt idl2`,
          ``,
          `end`,
          ``,
          `; main`,
          `compile_opt idl2`,
          ``,
          `; OK with only extra`,
          `auto_doc_example, /anything_i_want`,
          ``,
          `; OK with only ref extra`,
          `auto_doc_example2, /anything_i_want`,
          ``,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Check for known keywords`,
    fileName: `code.97.unknown-kw.exceptions2.spec.ts`,
    tests: [
      {
        name: `but always ignore extra and strict extra`,
        code: [
          `;+`,
          `; :Returns:`,
          `;   any`,
          `;`,
          `;-`,
          `function auto_doc_example`,
          `  compile_opt idl2`,
          ``,
          `  return, 1`,
          `end`,
          ``,
          `; main`,
          `compile_opt idl2`,
          ``,
          `; no error`,
          `a = auto_doc_example(_extra = !null)`,
          ``,
          `; no error`,
          `a = auto_doc_example(_strict_extra = !null)`,
          ``,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Check for known keywords`,
    fileName: `code.97.unknown-kw.exceptions3.spec.ts`,
    tests: [
      {
        name: `but always obj_new`,
        code: [
          `; main`,
          `compile_opt idl2`,
          ``,
          `; no error`,
          `outClass = 'something'`,
          `!null = OBJ_NEW(outClass, FOLD_CASE=!null))`,
          ``,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Check for incomplete ternary`,
    fileName: `code.98.incomplete-ternary.spec.ts`,
    tests: [
      {
        name: `operators missing the second half`,
        code: [
          `compile_opt idl2`,
          `; wrong`,
          `a = !true ? 5`,
          ``,
          `; right`,
          `!null = !true ? 5 : 'yeah'`,
          ``,
          `; right`,
          `!null = !true ? (5) : 'yeah'`,
          ``,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Detect undefined variables`,
    fileName: `code.99.undefined-var.spec.ts`,
    tests: [
      {
        name: `in most places`,
        code: [
          `;+`,
          `; :Arguments:`,
          `;   a: in, required, ENVIRaster`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;   b: out, required, Long`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;   c: out, required, ENVIRaster`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;`,
          `;-`,
          `pro undefined_without_common, a, b, c`,
          `  compile_opt idl2`,
          ``,
          `  ; direct vars`,
          `  test1 = bad`,
          ``,
          `  ; within child branches`,
          `  test2 = (ok = 5) + wrong`,
          ``,
          `  ; as keyword`,
          `  test3 = ENVIRaster(metadata = meta) ; formatting matches docs`,
          ``,
          `  ; OK`,
          `  for i = 0, 100 do begin`,
          `    !null = i`,
          `  endfor`,
          ``,
          `  ; item is bad`,
          `  foreach val, item, key do begin`,
          `    !null = val`,
          `    !null = key`,
          `  endforeach`,
          ``,
          `  ; noBueno is bad`,
          `  noBueno->method`,
          `end`,
        ],
      },
      {
        name: `never define self`,
        code: [
          `;+`,
          `; :Returns:`,
          `;   any`,
          `;`,
          `;-`,
          `function dataToMemoryRaster`,
          `  compile_opt idl2`,
          ``,
          `  ; should error`,
          `  self = 5`,
          ``,
          `  ; should error`,
          `  a = self`,
          ``,
          `  return, 1`,
          `end`,
        ],
      },
      {
        name: `define self in methods`,
        code: [
          `;+`,
          `; :Returns:`,
          `;   any`,
          `;`,
          `;-`,
          `function myclass::mymethod`,
          `  compile_opt idl2`,
          ``,
          `  ; no error`,
          `  self = 5`,
          ``,
          `  ; no error`,
          `  a = self`,
          ``,
          `  return, 1`,
          `end`,
        ],
      },
      {
        name: `catc`,
        code: [
          `compile_opt idl2`,
          `filename = filepath('qb_boulder_msi', root = nv.root_dir)`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Check unknown variables in edge cases`,
    fileName: `code.99.undefined-var.edge-cases.spec.ts`,
    tests: [
      {
        name: `in keywords`,
        code: [
          `compile_opt idl2`,
          `filename = filepath('qb_boulder_msi', root = nv.root_dir)`,
          `end`,
        ],
      },
      {
        name: `pointer value assignment`,
        code: [`compile_opt idl2`, `*other = 42`, `end`],
      },
    ],
  },
  {
    suiteName: `Don't check unknown keywords`,
    fileName: `code.99.undefined-var.exceptions1.spec.ts`,
    tests: [
      {
        name: `in in methods that we dont know`,
        code: [
          `  compile_opt idl2`,
          `l = luna(/in_package)`,
          `(l.expects(routine)).toRunFunction, raster, _output = output`,
          `end`,
        ],
      },
      {
        name: `verify we process parents before children`,
        code: [
          `  compile_opt idl2`,
          `  item = list()`,
          `  ; item is bad`,
          `  foreach val, item, key do begin`,
          `    val = 5`,
          `  endforeach`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Without docs, keywords are least restrictive`,
    fileName: `code.99.undefined-var.exceptions2.spec.ts`,
    tests: [
      {
        name: `and bidirectional`,
        code: [
          `pro unknown_kw_relaxed, kw = kw`,
          `compile_opt idl2`,
          `end`,
          ``,
          `; main`,
          `compile_opt idl2`,
          `unknown_kw_relaxed, kw = newVar`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Without known global, arguments are least restrictive`,
    fileName: `code.99.undefined-var.exceptions3.spec.ts`,
    tests: [
      {
        name: `and bidirectional`,
        code: [
          `;+`,
          `; :Returns:`,
          `;   any`,
          `;`,
          `; :Arguments:`,
          `;   data: bidirectional, required, any`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;`,
          `;-`,
          `function dataToMemoryRaster, data`,
          `  compile_opt idl2, hidden`,
          ``,
          `  ; make everything`,
          `  oSvc = obj_new('IDLcfSvcOpenMemoryRaster') ; IDLcfSvcOpenMemoryRaster()`,
          `  ok = oSvc.Open(memory_data = data, '', oRaster, data_type = data.typecode)`,
          `  ok = IDLcfGetServiceObject(!null, 'ManageRaster', oManageRaster)`,
          `  void = oManageRaster.ManageBands(oRaster)`,
          ``,
          `  ; return our raster`,
          `  return, ENVIWrapComponent(oRaster)`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Keyword variables should be defined`,
    fileName: `code.99.undefined-var.exceptions4.spec.ts`,
    tests: [
      {
        name: `and not report errors`,
        code: [
          `function bridge_it::Init, nbridges, init = init, msg = msg, logdir = logdir, nrefresh = nrefresh, prefix = prefix`,
          `compile_opt idl2, hidden`,
          ``,
          `; check to see if different messag eneeds to be used`,
          `if ~keyword_set(msg) then self.msg = 'Time to complete bridge process (sec): ' else self.msg = msg`,
          ``,
          `; check to see if we have a number of processes to complete before refreshing the bridges`,
          `; otherwise set the refresh number to an absurbly high result!`,
          `if keyword_set(nrefresh) then self.nrefresh = nrefresh else self.nrefresh = 1000000l`,
          ``,
          `; check if init keyword is set, if so then we want to save the init string`,
          `if keyword_set(init) then self.init = strjoin(init, ' & ')`,
          ``,
          `; check if logdir is specified`,
          `if keyword_set(logdir) then begin`,
          `  if file_test(logdir) then begin`,
          `    self.logdir = logdir`,
          `  endif else begin`,
          `    message, 'Specified LOGDIR does not exist!'`,
          `  endelse`,
          `endif`,
          ``,
          `return, 1`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `With lambda functions`,
    fileName: `code.99.undefined-var.exceptions5.spec.ts`,
    tests: [
      {
        name: 'do not extract or check variables',
        code: [
          `; main level`,
          `compile_opt idl2`,
          `!null = lambda(n:n le 3 || min(n mod [2:fix(sqrt(n))]))`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `With common blocks`,
    fileName: `code.99.undefined-var.exceptions6.spec.ts`,
    tests: [
      {
        name: 'skip the name of the common block',
        code: [
          `; main level`,
          `compile_opt idl2`,
          `common theName, a1, bb, cc`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Detect undefined variables`,
    fileName: `code.100.potential-undefined-var.spec.ts`,
    tests: [
      {
        name: `when we have a common block present`,
        code: [
          `;+`,
          `; :Arguments:`,
          `;   a: in, required, ENVIRaster`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;   b: out, required, Long`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;   c: out, required, ENVIRaster`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;`,
          `;-`,
          `pro undefined_with_common, a, b, c`,
          `  compile_opt idl2`,
          `  common`,
          ``,
          `  ; direct vars`,
          `  test1 = bad`,
          ``,
          `  ; within child branches`,
          `  test2 = (ok = 5) + wrong`,
          ``,
          `  ; as keyword`,
          `  test3 = ENVIRaster(metadata = meta) ; formatting matches docs`,
          ``,
          `  ; OK`,
          `  for i = 0, 100 do begin`,
          `    !null = i`,
          `  endfor`,
          ``,
          `  ; item is bad`,
          `  foreach val, item, key do begin`,
          `    !null = val`,
          `    !null = key`,
          `  endforeach`,
          ``,
          `  ; noBueno is bad`,
          `  noBueno->method`,
          `end`,
        ],
      },
      {
        name: `dont add a var for the first child of a common block`,
        code: [
          `pro color_edit_back`,
          `compile_opt idl2`,
          ``,
          `common color_edit, wxsize, wysize, r0`,
          ``,
          `for i = wysize - 60, wysize - 30 do tv, ramp, wxsize / 2 - 256, i`,
          ``,
          `cx = wxsize / 4.`,
          `cy = wysize - 90. - r0`,
          ``,
          `a = color_edit`,
          ``,
          `return`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Use variable before it is defined`,
    fileName: `code.101.var-use-before-def.spec.ts`,
    tests: [
      {
        name: `when we dont have a common-block present`,
        code: [
          `pro before_defined_no_common`,
          `compile_opt idl2`,
          ``,
          `; problemo`,
          `a = b`,
          ``,
          `; define`,
          `b = 5`,
          ``,
          `; complex problem0`,
          `c = d + (d = 5)`,
          ``,
          `; no problemo`,
          `f = (g = 6) + g`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Use variable before it is defined`,
    fileName: `code.101.var-use-before-def.exceptions.spec.ts`,
    tests: [
      {
        name: `does not trigger anywhere`,
        code: [
          `function ReadExif::_GetName, tag, image = img, photo = pht, gps = gps, iop = iop`,
          `compile_opt idl2, hidden`,
          ``,
          `name = ''`,
          `img = keyword_set(img)`,
          `pht = keyword_set(pht)`,
          `gps = keyword_set(gps)`,
          `iop = keyword_set(iop)`,
          ``,
          `; if none are set, default to all`,
          `if (array_equal([img, pht, gps, iop], 0)) then begin`,
          `  img = (pht = (gps = (iop = 1)))`,
          `endif`,
          ``,
          `if (iop) then begin`,
          `  if (self.ioptags.HasKey(tag)) then begin`,
          `    name = self.ioptags[tag]`,
          `  endif`,
          `endif`,
          ``,
          `if (gps) then begin`,
          `  if (self.gpstags.HasKey(tag)) then begin`,
          `    name = self.gpstags[tag]`,
          `  endif`,
          `endif`,
          ``,
          `if (pht) then begin`,
          `  if (self.phototags.HasKey(tag)) then begin`,
          `    name = self.phototags[tag]`,
          `  endif`,
          `endif`,
          ``,
          `if (img) then begin`,
          `  if (self.imagetags.HasKey(tag)) then begin`,
          `    name = self.imagetags[tag]`,
          `  endif`,
          `endif`,
          ``,
          `return, name`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Use variable before it is defined`,
    fileName: `code.102.potential-var-use-before-def.spec.ts`,
    tests: [
      {
        name: `when we dont have a common-block present`,
        code: [
          `pro before_defined_common`,
          `compile_opt idl2`,
          `common`,
          ``,
          `; problemo`,
          `a = b`,
          ``,
          `; define`,
          `b = 5`,
          ``,
          `; complex problem0`,
          `c = d + (d = 5)`,
          ``,
          `; no problemo`,
          `f = (g = 6) + g`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Use variable before it is defined`,
    fileName: `code.102.potential-var-use-before-def.exception.spec.ts`,
    tests: [
      {
        name: `does not get triggered here`,
        code: [
          `pro IDLitVisAxis2::OnViewportChange, oDestination`,
          `  compile_opt idl2, hidden`,
          ``,
          `  if (obj_valid(oDestination)) then $`,
          `    oDestination.GetProperty, current_zoom = zoomFactor $`,
          `  else $`,
          `    zoomFactor = 1.0`,
          ``,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Keywords that are abbreviated but`,
    fileName: `code.103.ambiguous-keyword-abbreviation.spec.ts`,
    tests: [
      {
        name: `have multiple for auto complete`,
        code: [
          `;+`,
          `; :Returns:`,
          `;   any`,
          `;`,
          `; :Keywords:`,
          `;   kw1: bidirectional, optional, any`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;   kw2: bidirectional, optional, any`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;`,
          `;-`,
          `function myclass::mymethod, kw1 = kw1, kw2 = kw2`,
          `  compile_opt idl2`,
          ``,
          `  return, 1`,
          `end`,
          ``,
          `;+`,
          `; :Keywords:`,
          `;   kw1: bidirectional, optional, any`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;   kw2: bidirectional, optional, any`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;`,
          `;-`,
          `pro myclass::mymethod, kw1 = kw1, kw2 = kw2`,
          `  compile_opt idl2`,
          ``,
          `end`,
          ``,
          `;+`,
          `; :myclass:`,
          `;-`,
          `pro myclass__define`,
          `  compile_opt idl2`,
          ``,
          `  !null = {myclass}`,
          ``,
          `end`,
          ``,
          `;+`,
          `; :Returns:`,
          `;   any`,
          `;`,
          `; :Keywords:`,
          `;   kw1: bidirectional, optional, any`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;   kw2: bidirectional, optional, any`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;`,
          `;-`,
          `function auto_doc_example, kw1 = kw1, kw2 = kw2`,
          `  compile_opt idl2`,
          ``,
          `  return, 1`,
          `end`,
          ``,
          `;+`,
          `; :Keywords:`,
          `;   kw1: bidirectional, optional, any`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;   kw2: bidirectional, optional, any`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;`,
          `;-`,
          `pro auto_doc_example, kw1 = kw1, kw2 = kw2`,
          `  compile_opt idl2`,
          ``,
          `end`,
          ``,
          `; main leve program`,
          `compile_opt idl2`,
          ``,
          `; problem 1`,
          `auto_doc_example, /kw`,
          ``,
          `; problem 2`,
          `!null = auto_doc_example(kw = 5)`,
          ``,
          `a = {myclass}`,
          ``,
          `; problem 3`,
          `a.mymethod, kw = 5`,
          ``,
          `; problem 4`,
          `!null = a.mymethod(/kw)`,
          ``,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Keywords that could be abbreviated`,
    fileName: `code.103.ambiguous-keyword-abbreviation.exceptions.spec.ts`,
    tests: [
      {
        name: `but have a direct match`,
        code: [
          `; main leve program`,
          `compile_opt idl2`,
          ``,
          `; problem 1`,
          `device, /close`,
          ``,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Unused variable`,
    fileName: `code.104.unused-var.spec.ts`,
    tests: [
      {
        name: `problems with args, kws, and vars`,
        code: [
          `function test1, a, b, kw = kw`,
          `  compile_opt idl2`,
          `  c = 5`,
          `  return, 1`,
          `end`,
        ],
      },
      {
        name: `no problems when used`,
        code: [
          `function test1, a, b, kw = kw`,
          `  compile_opt idl2`,
          `  c = 5`,
          `  !null = a + b + c + keyword_set(kw)`,
          `  return, 1`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Unused variable`,
    fileName: `code.104.unused-var.exceptions1.spec.ts`,
    tests: [
      {
        name: `exceptions for static references`,
        code: [`compile_opt idl2`, `!null = ENVI.openRaster()`, `end`],
      },
    ],
  },
  {
    suiteName: `Unused var exceptions when parentheses for indexing`,
    fileName: `code.104.unused-var.exceptions2.spec.ts`,
    tests: [
      {
        name: `is var`,
        code: [`;+ my var`, `a = 5`, ``, `!null = a()`, ``, `end`],
      },
      {
        name: `is not var`,
        code: [`compile_opt strictarr`, `a = 5`, ``, `!null = a()`, ``, `end`],
      },
      {
        name: `is not var`,
        code: [`compile_opt idl2`, `a = 5`, ``, `!null = a()`, ``, `end`],
      },
      {
        name: `is not var`,
        code: [`compile_opt idl3`, `a = 5`, ``, `!null = a()`, ``, `end`],
      },
    ],
  },
  {
    suiteName: `Indexing with parentheses`,
    fileName: `code.105.illegal-var-index.spec.ts`,
    tests: [
      {
        name: `for simple case`,
        code: [`;+ my var`, `a = 5`, ``, `!null = a()`, ``, `end`],
      },
      {
        name: `do no change when compile opt strictarr`,
        code: [`compile_opt strictarr`, `a = 5`, ``, `!null = a()`, ``, `end`],
      },
      {
        name: `do no change when compile opt idl2`,
        code: [`compile_opt idl2`, `a = 5`, ``, `!null = a()`, ``, `end`],
      },
      {
        name: `do no change when compile opt idl3`,
        code: [`compile_opt idl3`, `a = 5`, ``, `!null = a()`, ``, `end`],
      },
    ],
  },
  {
    suiteName: `All the places we want to make sure we test for`,
    fileName: `type-validation-reference.spec.ts`,
    tests: [
      {
        name: `type validation`,
        code: [
          `;+`,
          `; :Arguments:`,
          `;   arg3: in, required, Hash<any>`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;   arg4: in, required, OrderedHash<Byte>`,
          `;     Placeholder docs for argument, keyword, or property`,
          `;`,
          `;-`,
          `pro validate_problems, arg3, arg4`,
          `  compile_opt idl3`,
          ``,
          `  ; validation edge cases`,
          `  ; same variables should always have validation applied, but not always saved`,
          `  dup1 = arg3[arg4]`,
          `  dup1 = arg3[arg4]`,
          ``,
          `  ; anything with assignment before should validate`,
          `  !x.charsize = arg3[arg4]`,
          `  !null = arg3[arg4]`,
          ``,
          `  ; arguments and keywords`,
          `  a = polot1(arg3[arg4], $`,
          `    arg3[arg4], $`,
          `    thing = arg3[arg4], $`,
          `    thang = arg3[arg4])`,
          ``,
          `  ; left-side of the equation`,
          `  arg3[arg4] = 5`,
          `  (arg3[arg4]) = 5`,
          `  (myfunc(arg3[arg4])) = 5`,
          `  !null = (myfunc2(arg3[arg4]))`,
          `  !null = (myfunc3(arg3[arg4])) + 1`,
          ``,
          `  ; arguments`,
          `  a = polot2(arg3[arg4], arg3[arg4])`,
          `end`,
        ],
      },
    ],
  },
  {
    suiteName: `Properly reports problems for docs`,
    fileName: `docs-problems-when-docs-below.spec.ts`,
    tests: [
      {
        name: `when blocks are inside procedures`,
        code: [
          `pro auto_doc_dont_add_above, input_raster = input_raster, output_raster_uri = output_raster_uri, third2 = third`,
          `;+`,
          `; :Keywords:`,
          `;   input_raster: in, optional, ENVIRaster`,
          `;     Thing 1`,
          `;   output_raster_uri: in, optional, String`,
          `;     Thing 2`,
          `;   third: bidirectional, optional, any`,
          `;     Thing 3`,
          `;`,
          `;-`,
          `compile_opt idl2`,
          ``,
          `; get the current session of ENVI`,
          `e = envi(/current)`,
          `if (e eq !null) then begin`,
          `  message, 'ENVI has not started yet, required!'`,
          `endif`,
          `idltasktest, input_raster = 5`,
          `end`,
        ],
      },
      {
        name: `when blocks are inside functions`,
        code: [
          `function auto_doc_dont_add_above, input_raster = input_raster, output_raster_uri = output_raster_uri, third2 = third`,
          `;+`,
          `; :Keywords:`,
          `;   input_raster: in, optional, ENVIRaster`,
          `;     Thing 1`,
          `;   output_raster_uri: in, optional, String`,
          `;     Thing 2`,
          `;   third: bidirectional, optional, any`,
          `;     Thing 3`,
          `;`,
          `;-`,
          `compile_opt idl2`,
          ``,
          `; get the current session of ENVI`,
          `e = envi(/current)`,
          `if (e eq !null) then begin`,
          `  message, 'ENVI has not started yet, required!'`,
          `endif`,
          `idltasktest, input_raster = 5`,
          `rturn, 1`,
          `end`,
        ],
      },
      {
        name: `when blocks are inside functions`,
        code: [
          `;+`,
          `; No problems for me!!! Im care free!!!`,
          `;-`,
          ``,
          ``,
          `function auto_doc_dont_add_above, input_raster = input_raster, output_raster_uri = output_raster_uri, third = third`,
          `;+`,
          `; :Keywords:`,
          `;   input_raster: in, optional, ENVIRaster`,
          `;     Thing 1`,
          `;   output_raster_uri: in, optional, String`,
          `;     Thing 2`,
          `;   third: bidirectional, optional, any`,
          `;     Thing 3`,
          `;`,
          `;-`,
          `compile_opt idl2`,
          ``,
          `; get the current session of ENVI`,
          `e = envi(/current)`,
          `if (e eq !null) then begin`,
          `  message, 'ENVI has not started yet, required!'`,
          `endif`,
          `idltasktest, input_raster = 5`,
          `rturn, 1`,
          `end`,
        ],
      },
    ],
  },
];
